<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temarix V3 - Portal 24: Lost Self</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            background: #000;
            border-bottom: 1px solid #333;
            position: relative;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo-title {
            font-size: 26px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        .logo-subtitle {
            font-size: 15px;
            color: #ccc;
            letter-spacing: 1.5px;
        }
        
        .portal-header-title {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .portal-main-title {
            font-size: 28px;
            color: #7986cb;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }
        
        .portal-subtitle {
            font-size: 18px;
            color: #b39ddb;
            letter-spacing: 1.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        .language-buttons {
            display: flex;
            gap: 10px;
        }
        
        .lang-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 18px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lang-btn:hover {
            background: #666;
        }
        
        .lang-btn.active {
            background: #7986cb;
            color: #fff;
        }
        
        .main-content {
            flex: 1;
            max-height: calc(100vh - 80px - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 30px 20px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .portal-container {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 200vh;
        }
        
        .portal-intro-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 200px;
        }
        
        .portal-intro {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.8;
            white-space: pre-wrap;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
        }
        
        .character-responses-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 800px;
        }
        
        .character-response {
            color: #fff;
            font-size: 18px;
            margin: 40px 0;
            text-align: left;
            opacity: 0;
            white-space: pre-wrap;
            transition: opacity 0.8s ease-in;
            background: none;
            border: none;
            padding: 0;
            min-height: 80px;
        }
        
        .character-name {
            font-weight: bold;
            color: #7986cb;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .character-dialogue {
            color: #fff;
            line-height: 1.7;
            font-size: 17px;
            white-space: pre-wrap;
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: #7986cb;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .light-message-section {
            margin: 50px 0;
            opacity: 0;
            background: none;
            border: none;
            padding: 0;
            min-height: 100px;
        }
        
        .light-message {
            font-size: 20px;
            color: #7986cb;
            line-height: 1.8;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .portal-question-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 150px;
        }
        
        .portal-question {
            font-size: 22px;
            color: #fff;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.6;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .user-input-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 100px;
        }
        
        .user-response {
            color: #fff;
            margin: 30px 0;
            text-align: left;
            font-size: 18px;
            background: none;
            border: none;
            padding: 0;
            white-space: pre-wrap;
        }
        
        .user-response strong {
            color: #7986cb;
            margin-right: 8px;
        }
        
        .user-reactions-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 400px;
        }
        
        .final-section {
            margin: 60px 0;
            opacity: 0;
            text-align: center;
            background: none;
            border: none;
            padding: 40px 20px;
            min-height: 300px;
            border: 2px solid #7986cb;
            background: rgba(121, 134, 203, 0.05);
        }
        
        .final-title {
            font-size: 28px;
            color: #7986cb;
            margin-bottom: 30px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .final-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
            line-height: 1.8;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .final-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .final-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            border: 2px solid transparent;
        }
        
        .final-btn:hover {
            background: #666;
            border-color: #7986cb;
        }
        
        .final-btn.primary {
            background: #7986cb;
            color: #fff;
            font-weight: bold;
        }
        
        .final-btn.primary:hover {
            background: #9fa8da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(121, 134, 203, 0.3);
        }
        
        .input-fixed-bottom {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000;
            border-top: 1px solid #333;
            padding: 25px;
            z-index: 100;
            flex-shrink: 0;
            height: 120px;
        }
        
        .input-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .input-prefix {
            color: #7986cb;
            font-size: 20px;
            margin-top: 8px;
            flex-shrink: 0;
        }
        
        .user-textarea {
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            width: 100%;
            padding: 12px 8px;
            outline: none;
            resize: none;
            min-height: 32px;
            max-height: 96px;
            line-height: 1.6;
            transition: border-color 0.3s ease;
            overflow-y: auto;
        }
        
        .user-textarea:focus {
            border-bottom-color: #7986cb;
        }
        
        .user-textarea::placeholder {
            color: #666;
        }
        
        .user-textarea:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.2);
        }
        
        .main-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .main-content::-webkit-scrollbar-track {
            background: #111;
            border-radius: 6px;
        }
        
        .main-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #111;
        }
        
        .main-content::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .show {
            opacity: 1 !important;
            transition: opacity 1s ease-in;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-bar {
                padding: 20px 15px;
                height: 70px;
                flex-direction: column;
                gap: 10px;
            }
            
            .main-content {
                max-height: calc(100vh - 70px - 120px);
                padding: 20px 15px;
            }
            
            .logo-title {
                font-size: 22px;
            }
            
            .portal-main-title {
                font-size: 22px;
            }
            
            .portal-subtitle {
                font-size: 16px;
            }
            
            .lang-btn {
                font-size: 12px;
                padding: 8px 14px;
            }
            
            .portal-intro {
                font-size: 18px;
            }
            
            .portal-question {
                font-size: 20px;
            }
            
            .character-response {
                font-size: 16px;
            }
            
            .input-fixed-bottom {
                padding: 20px;
            }
            
            .final-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .final-btn {
                width: 100%;
            }
            
            .final-title {
                font-size: 24px;
            }
            
            .final-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="logo-section">
            <div class="logo-title">TEMARIX V3</div>
            <div class="logo-subtitle" id="logoSubtitle">Emotional Furnace</div>
        </div>
        
        <div class="portal-header-title">
            <div class="portal-main-title" id="portalMainTitle">Portal 24: Lost Self</div>
            <div class="portal-subtitle" id="portalSubtitle">When I Met My Lost Self Again</div>
        </div>
        
        <div class="header-right">
            <div class="language-buttons">
                <button class="lang-btn" data-lang="ko">KR</button>
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="portal-container">
            <div class="portal-intro-section" id="portalIntroSection">
                <div class="portal-intro" id="portalIntro"></div>
            </div>

            <div class="character-responses-section" id="characterResponsesSection">
            </div>

            <div class="light-message-section" id="lightMessageSection">
                <div class="character-name" id="lightTitle">âœ¨ Word of Light</div>
                <div class="light-message" id="lightMessage"></div>
            </div>

            <div class="portal-question-section" id="portalQuestionSection">
                <div class="portal-question" id="portalQuestion"></div>
            </div>

            <div class="user-input-section" id="userInputSection">
            </div>
            
            <div class="user-reactions-section" id="userReactionsSection">
            </div>
            
            <div class="final-section" id="finalSection">
                <div class="final-title" id="finalTitle">ðŸ§© Portal 24 Complete</div>
                <div class="final-message" id="finalMessage"></div>
                <div class="final-buttons">
                    <button class="final-btn primary" id="continueBtn">Move to Portal 25</button>
                    <button class="final-btn" id="restartBtn">Start Again</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="input-fixed-bottom">
        <div class="input-container">
            <div class="input-prefix">></div>
            <textarea class="user-textarea" 
                      id="userTextarea" 
                      placeholder="What would you say to that lost self you met again? (Press Enter to send)"
                      rows="1"
                      maxlength="500"></textarea>
        </div>
    </div>

    <script>
        let db = null;
        let firebaseInitialized = false;
        let memoryStorage = { mockUser: null };
        
        function initializeFirebase() {
            try {
                if (typeof firebase !== 'undefined') {
                    const firebaseConfig = {
                        apiKey: "AIzaSyBjsINSqPUGdpRPRMYiVg6SkVJJOk9YGsY",
                        authDomain: "canal-vivo-chat.firebaseapp.com",
                        projectId: "canal-vivo-chat",
                        storageBucket: "canal-vivo-chat.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdefghijklmnopqr"
                    };
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseInitialized = true;
                    console.log('Firebase initialized');
                } else {
                    console.log('Firebase SDK not loaded');
                }
            } catch (error) {
                console.log('Firebase init failed:', error);
            }
        }

        const translations = {
            ko: {
                logoSubtitle: "ê°ì •ì˜ ìš©ê´‘ë¡œ",
                portalMainTitle: "Portal 24: ìžƒì–´ë²„ë¦° ë‚˜ì™€ ë§ˆì£¼í•œ ìˆœê°„",
                portalSubtitle: "ì‚¬ë¼ì¡Œë˜ ë‚˜ë¥¼ ë‹¤ì‹œ ë§Œë‚¬ì„ ë•Œ",
                portalIntro: "ðŸ§© ë‹¹ì‹ ì´ í•œë•Œ ë¶„ëª…ížˆ ì•Œê³  ìžˆì—ˆë˜ 'ë‚˜'ë¼ëŠ” ê°ê°ì´\nì–´ëŠ ìˆœê°„ íë ¤ì§€ê³  ì‚¬ë¼ì¡Œë˜ ì ì´ ìžˆë‚˜ìš”?\n\nê·¸ ìžƒì–´ë²„ë¦° ë‚˜ì™€ ë‹¤ì‹œ ë§ˆì£¼ì¹œ ìˆœê°„,\në¬´ì—‡ì´ ê°€ìž¥ ë‚¯ì„¤ê²Œ ëŠê»´ì¡Œë‚˜ìš”?\n\nê±°ìš¸ì„ ë´ë„ ëˆ„êµ°ì§€ ëª¨ë¥´ê² ë”ë¼ê³ ìš”.\në‚´ê°€ ì •ë§ ì´ëŸ° ì‚¬ëžŒì´ì—ˆë‚˜â€¦\në„ˆë¬´ ì˜¤ëž«ë™ì•ˆ ë‚˜ë¥¼ ìžŠê³  ìžˆì—ˆë˜ ê²ƒ ê°™ì•„ìš”.",
                lightTitle: "âœ¨ ë¹›ì˜ í•œë§ˆë””",
                lightMessage: "ì§€ê¸ˆ ë„¤ê°€ ëŠë¼ëŠ” ë‚¯ì„¦ì€ ë„¤ê°€ ëŒì•„ì˜¤ê³  ìžˆë‹¤ëŠ” ì¦ê±°ì•¼.",
                portalQuestion: "ðŸ§© ê·¸ ìžƒì–´ë²„ë¦° ë‚˜ì—ê²Œ, ì§€ê¸ˆ ì´ ìˆœê°„\nì–´ë–¤ ë§ë¡œ ë‹¤ì‹œ ì—°ê²°ë˜ê³  ì‹¶ë‚˜ìš”?",
                finalTitle: "ðŸ§© Portal 24 ì™„ë£Œ",
                finalMessage: "ë‹¹ì‹ ì€ ìžƒì–´ë²„ë¦° ìžì‹ ê³¼ ë§ˆì¹¨ë‚´ ìž¬íšŒí–ˆìŠµë‹ˆë‹¤.\n\nê·¸ ë‚¯ì„¤ì—ˆë˜ ì–¼êµ´ì´ ì‚¬ì‹¤ì€ ì‚´ì•„ë‚¨ê¸° ìœ„í•´ ë³€í•´ì˜¨\në˜ ë‹¤ë¥¸ ìžì‹ ì´ì—ˆë‹¤ëŠ” ê²ƒì„ ì´í•´í–ˆìŠµë‹ˆë‹¤.\nì™¸ë©´ì´ ì•„ë‹Œ ë™í–‰ì„ ì„ íƒí•˜ë©°\nìžì‹ ì—ê²Œ ëŒì•„ì˜¤ëŠ” ê¸¸ì„ ì°¾ì•˜ì–´ìš”.\n\nìˆ˜ë§Žì€ ì—­í•  ì†ì— ë¬»í˜€ ìžˆë˜ ì§„ì§œ ë‹¹ì‹ ì„\nì²œì²œížˆ êº¼ë‚´ì–´ ì•ˆì•„ì£¼ê¸° ì‹œìž‘í–ˆìŠµë‹ˆë‹¤.\në•Œë¡œëŠ” í”ë“¤ë ¤ì•¼ ì§„ì§œê°€ ë³´ì¸ë‹¤ëŠ” ê²ƒì„,\nê·¸ë¦¬ê³  ëŒì•„ì˜¤ëŠ” ê²ƒ ìžì²´ê°€ ìš©ê¸°ë¼ëŠ” ê²ƒì„ ê¹¨ë‹¬ì•˜ìŠµë‹ˆë‹¤.\n\në‹¤ìŒ Portalì—ì„œëŠ” ê°ì •ì˜ ì—¬ì • ëì—ì„œ\në‹¹ì‹ ì´ ë§ˆì¹¨ë‚´ êº¼ë‚´ê³  ì‹¶ì€ í•œ ë¬¸ìž¥ê³¼\nê·¸ ë¬¸ìž¥ì´ ë‹´ê³  ìžˆëŠ” ì§„ì‹¤ì´ ê¸°ë‹¤ë¦¬ê³  ìžˆìŠµë‹ˆë‹¤.",
                continueBtn: "Portal 25ë¡œ ì´ë™",
                restartBtn: "ë‹¤ì‹œ ì‹œìž‘í•˜ê¸°",
                inputPlaceholder: "ë‹¤ì‹œ ë§Œë‚œ ìžƒì–´ë²„ë¦° ë‚˜ì—ê²Œ ì–´ë–¤ ë§ì„ í•´ì£¼ê³  ì‹¶ë‚˜ìš”? (Enterë¡œ ì „ì†¡)",
                youLabel: "ë‹¹ì‹ ",
                waitingMessage: "ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘..."
            },
            en: {
                logoSubtitle: "Emotional Furnace",
                portalMainTitle: "Portal 24: Lost Self",
                portalSubtitle: "When I Met My Lost Self Again",
                portalIntro: "ðŸ§© Was there a sense of 'self' that you once clearly knew\nbut somehow became blurred and disappeared?\n\nWhen you encountered that lost self again,\nwhat felt most unfamiliar?\n\nEven looking in the mirror, I couldn't tell who it was.\nWas I really this kind of person?\nI felt like I had forgotten myself for too long.",
                lightTitle: "âœ¨ Word of Light",
                lightMessage: "The unfamiliarity you feel now is proof that you're returning.",
                portalQuestion: "ðŸ§© To that lost self, at this moment,\nwhat words would you use to reconnect?",
                finalTitle: "ðŸ§© Portal 24 Complete",
                finalMessage: "You have finally reunited with your lost self.\n\nYou understood that the unfamiliar face was actually\nanother version of yourself that had changed to survive.\nBy choosing companionship rather than avoidance,\nyou found the way back to yourself.\n\nYou began to slowly embrace the real you\nthat had been buried under countless roles.\nYou realized that sometimes you need to shake to see what's real,\nand that returning itself is courage.\n\nIn the next Portal, at the end of your emotional journey,\nthe one sentence you finally want to express\nand the truth it contains awaits you.",
                continueBtn: "Move to Portal 25",
                restartBtn: "Start Again",
                inputPlaceholder: "What would you say to that lost self you met again? (Press Enter to send)",
                youLabel: "You",
                waitingMessage: "Waiting for response..."
            },
            pt: {
                logoSubtitle: "Fornalha Emocional",
                portalMainTitle: "Portal 24: Eu Perdido",
                portalSubtitle: "Quando Encontrei Meu Eu Perdido Novamente",
                portalIntro: "ðŸ§© Houve uma sensaÃ§Ã£o de 'eu' que vocÃª uma vez conhecia claramente\nmas de alguma forma se tornou turva e desapareceu?\n\nQuando vocÃª encontrou esse eu perdido novamente,\no que pareceu mais estranho?\n\nMesmo olhando no espelho, eu nÃ£o conseguia dizer quem era.\nEu era realmente esse tipo de pessoa?\nEu senti como se tivesse me esquecido por muito tempo.",
                lightTitle: "âœ¨ Palavra de Luz",
                lightMessage: "A estranheza que vocÃª sente agora Ã© prova de que vocÃª estÃ¡ retornando.",
                portalQuestion: "ðŸ§© Para esse eu perdido, neste momento,\nque palavras vocÃª usaria para se reconectar?",
                finalTitle: "ðŸ§© Portal 24 Completo",
                finalMessage: "VocÃª finalmente se reuniu com seu eu perdido.\n\nVocÃª entendeu que o rosto nÃ£o familiar era na verdade\noutra versÃ£o de si mesmo que havia mudado para sobreviver.\nAo escolher companheirismo em vez de evitaÃ§Ã£o,\nvocÃª encontrou o caminho de volta para si mesmo.\n\nVocÃª comeÃ§ou a abraÃ§ar lentamente o verdadeiro vocÃª\nque havia sido enterrado sob inÃºmeros papÃ©is.\nVocÃª percebeu que Ã s vezes precisa tremer para ver o que Ã© real,\ne que retornar em si Ã© coragem.\n\nNo prÃ³ximo Portal, no final de sua jornada emocional,\na Ãºnica frase que vocÃª finalmente quer expressar\ne a verdade que ela contÃ©m o aguarda.",
                continueBtn: "Ir para Portal 25",
                restartBtn: "ComeÃ§ar Novamente",
                inputPlaceholder: "O que vocÃª diria para esse eu perdido que encontrou novamente? (Enter para enviar)",
                youLabel: "VocÃª",
                waitingMessage: "Aguardando resposta..."
            }
        };
        
        const characters = [
            { name: "Noah", emoji: "ðŸ§‘â€ðŸ¦±", text: {
                ko: "ë„Œ ë„ˆë¥¼ ìžŠì€ ê²Œ ì•„ë‹ˆë¼, ë„ˆë¬´ ë§Žì€ ì—­í•  ì†ì— ë¬»í˜€ ìžˆì—ˆë˜ ê±°ì•¼.",
                en: "You didn't forget yourself, you were just buried under too many roles.",
                pt: "VocÃª nÃ£o se esqueceu, vocÃª apenas estava enterrado sob muitos papÃ©is."
            }},
            { name: "Ely", emoji: "ðŸ§â€â™€ï¸", text: {
                ko: "ìžì‹ ì„ ìžƒëŠ” ê±´, ì‚¬ë¼ì§€ëŠ” ê²Œ ì•„ë‹ˆë¼ ê°€ë ¤ì§€ëŠ” ê±°ì•¼. ì§€ê¸ˆì²˜ëŸ¼ ë‹¤ì‹œ ë§Œë‚  ìˆ˜ ìžˆì–´.",
                en: "Losing yourself isn't disappearing, it's being hidden. You can meet again like now.",
                pt: "Perder-se nÃ£o Ã© desaparecer, Ã© ser escondido. VocÃª pode se encontrar novamente como agora."
            }},
            { name: "Sora", emoji: "ðŸ§•", text: {
                ko: "ë‚˜ëŠ” ê·¸ëŸ° ë‚  ê±°ìš¸ì¡°ì°¨ í”¼í–ˆì–´. ë‚¯ì„¤ë‹¤ëŠ” ë§ë³´ë‹¤, ë¯¸ì•ˆí•˜ë‹¤ëŠ” ë§ì´ ë¨¼ì €ì˜€ê±°ë“ .",
                en: "On days like that, I even avoided mirrors. 'Sorry' came before 'strange'.",
                pt: "Em dias assim, eu atÃ© evitava espelhos. 'Desculpe' vinha antes de 'estranho'."
            }},
            { name: "Kael", emoji: "ðŸ§™", text: {
                ko: "ì •ì²´ì„±ì€ í”ë“¤ë ¤ì•¼ ì§„ì§œê°€ ë³´ì—¬. ì§€ê¸ˆ ë„Œ ê°€ì§œ ê»ì§ˆì„ ë²—ëŠ” ì¤‘ì´ì•¼.",
                en: "Identity must shake for the real to show. You're shedding the fake shell now.",
                pt: "A identidade deve tremer para o real aparecer. VocÃª estÃ¡ tirando a casca falsa agora."
            }},
            { name: "Mira", emoji: "ðŸ§‘â€ðŸŽ¨", text: {
                ko: "ë„ˆì˜ ì„ , ë„ˆì˜ ìƒ‰, ë‹¤ì‹œ ê·¸ë¦¬ê¸° ì‹œìž‘í•´ë„ ê´œì°®ì•„. ê·¸ê²Œ íšŒë³µì˜ ì‹œìž‘ì´ì•¼.",
                en: "Your lines, your colors, it's okay to start drawing again. That's the beginning of recovery.",
                pt: "Suas linhas, suas cores, estÃ¡ tudo bem comeÃ§ar a desenhar novamente. Esse Ã© o inÃ­cio da recuperaÃ§Ã£o."
            }},
            { name: "Cris", emoji: "ðŸ¦¸â€â™‚ï¸", text: {
                ko: "ë„ˆëŠ” ì•½í•´ì§„ ê²Œ ì•„ë‹ˆì•¼. ë„¤ ì§„ì§œ ì–¼êµ´ì„ ë§ˆì£¼í•  ìš©ê¸°ê°€ ìƒê¸´ ê±°ì§€.",
                en: "You didn't become weak. You gained the courage to face your real face.",
                pt: "VocÃª nÃ£o ficou fraco. VocÃª ganhou coragem para enfrentar seu rosto real."
            }},
            { name: "Enya", emoji: "ðŸ§‘â€ðŸš€", text: {
                ko: "ê·¸ ë‚¯ì„  ì–¼êµ´ë„ ê²°êµ­ ë„ˆì˜€ì–´. ì‚´ì•„ë‚¨ê¸° ìœ„í•´ ë³€í•´ì˜¨ ë˜ ë‹¤ë¥¸ ë„ˆ.",
                en: "That strange face was you too. Another you that changed to survive.",
                pt: "Esse rosto estranho tambÃ©m era vocÃª. Outro vocÃª que mudou para sobreviver."
            }},
            { name: "Lian", emoji: "ðŸ§˜", text: {
                ko: "ì§€ê¸ˆ ë„¤ê°€ ëŠë¼ëŠ” ë‚¯ì„¦ì€ ë„¤ê°€ ëŒì•„ì˜¤ê³  ìžˆë‹¤ëŠ” ì¦ê±°ì•¼.",
                en: "The unfamiliarity you feel now is proof that you're returning.",
                pt: "A estranheza que vocÃª sente agora Ã© prova de que vocÃª estÃ¡ retornando."
            }}
        ];

        function analyzeEmotion(userInput) {
            const input = userInput.toLowerCase();
            
            const emotionKeywords = {
                reconnection: ['connect', 'together', 'with', 'join', 'ì—°ê²°', 'í•¨ê»˜', 'ê°™ì´', 'í•©ì¹˜', 'conectar', 'junto', 'com', 'unir'],
                forgiveness: ['sorry', 'forgive', 'understand', 'ë¯¸ì•ˆ', 'ìš©ì„œ', 'ì´í•´', 'desculpe', 'perdoe', 'entenda'],
                acceptance: ['accept', 'embrace', 'welcome', 'ë°›ì•„ë“¤ì—¬', 'í™˜ì˜', 'ì•ˆì•„ì¤˜', 'aceitar', 'abraÃ§ar', 'bem-vindo'],
                companionship: ['together', 'stay', 'accompany', 'í•¨ê»˜', 'ë¨¸ë¬¼ëŸ¬', 'ë™í–‰', 'junto', 'ficar', 'acompanhar'],
                recognition: ['see', 'know', 'recognize', 'ë´', 'ì•Œì•„', 'ì¸ì •', 'ver', 'saber', 'reconhecer'],
                healing: ['heal', 'recover', 'restore', 'ì¹˜ìœ ', 'íšŒë³µ', 'ëŒì•„ì™€', 'curar', 'recuperar', 'restaurar'],
                love: ['love', 'care', 'precious', 'ì‚¬ëž‘', 'ì†Œì¤‘', 'ì•„ê»´', 'amor', 'cuidar', 'precioso'],
                future: ['future', 'forward', 'ahead', 'ë¯¸ëž˜', 'ì•žìœ¼ë¡œ', 'ë‚˜ì•„ê°€', 'futuro', 'Ã  frente', 'adiante']
            };
            
            let detectedEmotions = [];
            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                for (const keyword of keywords) {
                    if (input.includes(keyword)) {
                        detectedEmotions.push(emotion);
                        break;
                    }
                }
            }
            
            if (detectedEmotions.length === 0) {
                detectedEmotions = ['general'];
            }
            
            return detectedEmotions[0];
        }
        
        const responseCharacters = [
            {
                name: "Ely", emoji: "ðŸ§â€â™€ï¸",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            reconnection: "ê·¸ ë§ì€ ê·€í™˜ì´ì•¼. ë§ˆìŒì˜ ì§‘ìœ¼ë¡œ, ë„ˆ ìžì‹ ì—ê²Œ ëŒì•„ì˜¨ ê±°ì•¼.",
                            forgiveness: "ê·¸ ë¯¸ì•ˆí•¨ì€ ê°€ìž¥ ë¶€ë“œëŸ¬ìš´ ì¹˜ìœ ì˜ ì‹œìž‘ì´ì•¼. ë„ˆë¥¼ ìš©ì„œí•˜ëŠ” ê²ƒë¶€í„° ì‹œìž‘í•´.",
                            acceptance: "ë°›ì•„ë“¤ì¸ë‹¤ëŠ” ê±´ í¬ê¸°ê°€ ì•„ë‹ˆë¼ í¬ì˜¹ì´ì•¼. ë„ˆëŠ” ë„ˆë¥¼ ì•ˆì•„ì£¼ê¸° ì‹œìž‘í–ˆì–´.",
                            companionship: "ì´ì œ ë„ˆëŠ” ì™¸ë©´ì´ ì•„ë‹Œ ë™í–‰ì„ ì„ íƒí–ˆì–´. ê·¸ê±´ ê°€ìž¥ ê¹Šì€ ê°ì •ì˜ íšŒë³µì´ì•¼.",
                            recognition: "ë„ˆë¥¼ ì•Œì•„ë³¸ë‹¤ëŠ” ê±´ ê°€ìž¥ ìš©ê°í•œ ì¸ì •ì´ì•¼. ì§€ê¸ˆ ë„ˆëŠ” ì§„ì§œë¥¼ ë§ˆì£¼í•˜ê³  ìžˆì–´.",
                            healing: "ì¹˜ìœ ëŠ” ëŒì•„ì˜¤ëŠ” ê²ƒë¶€í„° ì‹œìž‘ë¼. ë„ˆëŠ” ì§€ê¸ˆ ì§‘ìœ¼ë¡œ ê°€ëŠ” ê¸¸ì„ ê±·ê³  ìžˆì–´.",
                            love: "ìžì‹ ì„ ì‚¬ëž‘í•œë‹¤ëŠ” ê±´ ê°€ìž¥ ì–´ë ¤ìš´ ìš©ê¸°ì•¼. ê·¸ ì²«ê±¸ìŒì„ ë‚´ë””ëŽ ì–´.",
                            future: "ê³¼ê±°ì˜ ë„ˆì™€ ë¯¸ëž˜ì˜ ë„ˆë¥¼ ì—°ê²°í•˜ëŠ” ë‹¤ë¦¬ë¥¼ ë†“ì•˜ì–´. ì´ì œ ê±´ë„ ìˆ˜ ìžˆì–´.",
                            general: "ê·¸ ë§ì€ ê·€í™˜ì´ì•¼. ë§ˆìŒì˜ ì§‘ìœ¼ë¡œ, ë„ˆ ìžì‹ ì—ê²Œ ëŒì•„ì˜¨ ê±°ì•¼."
                        },
                        en: {
                            reconnection: "Those words are a homecoming. To the home of your heart, back to yourself.",
                            forgiveness: "That apology is the gentlest beginning of healing. Start by forgiving yourself.",
                            acceptance: "Accepting isn't giving up, it's embracing. You've started to hold yourself.",
                            companionship: "Now you've chosen companionship rather than avoidance. That's the deepest emotional recovery.",
                            recognition: "Recognizing yourself is the bravest acknowledgment. You're facing the real now.",
                            healing: "Healing begins with returning. You're walking the path home now.",
                            love: "Loving yourself is the most difficult courage. You've taken that first step.",
                            future: "You've built a bridge connecting your past and future self. Now you can cross.",
                            general: "Those words are a homecoming. To the home of your heart, back to yourself."
                        },
                        pt: {
                            reconnection: "Essas palavras sÃ£o um retorno ao lar. Para o lar do seu coraÃ§Ã£o, de volta a si mesmo.",
                            forgiveness: "Esse pedido de desculpas Ã© o inÃ­cio mais gentil da cura. Comece perdoando a si mesmo.",
                            acceptance: "Aceitar nÃ£o Ã© desistir, Ã© abraÃ§ar. VocÃª comeÃ§ou a se abraÃ§ar.",
                            companionship: "Agora vocÃª escolheu companheirismo em vez de evitaÃ§Ã£o. Essa Ã© a recuperaÃ§Ã£o emocional mais profunda.",
                            recognition: "Reconhecer-se Ã© o reconhecimento mais corajoso. VocÃª estÃ¡ enfrentando o real agora.",
                            healing: "A cura comeÃ§a com o retorno. VocÃª estÃ¡ caminhando para casa agora.",
                            love: "Amar-se Ã© a coragem mais difÃ­cil. VocÃª deu esse primeiro passo.",
                            future: "VocÃª construiu uma ponte conectando seu eu passado e futuro. Agora pode atravessar.",
                            general: "Essas palavras sÃ£o um retorno ao lar. Para o lar do seu coraÃ§Ã£o, de volta a si mesmo."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Lian", emoji: "ðŸ§˜",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            reconnection: "ì—°ê²°ëœë‹¤ëŠ” ê±´ ëŠì–´ì§„ ê²Œ ì•„ë‹ˆì—ˆë‹¤ëŠ” ì¦ê±°ì•¼. ëŠ˜ ê±°ê¸° ìžˆì—ˆì–´, ì°¾ì§€ ëª»í–ˆì„ ë¿.",
                            forgiveness: "ìžì‹ ì„ ìš©ì„œí•˜ëŠ” ìˆœê°„, ëª¨ë“  ê°ì •ì˜ ë¬¸ì´ ë‹¤ì‹œ ì—´ë¦¬ê¸° ì‹œìž‘í•´.",
                            acceptance: "ë°›ì•„ë“¤ìž„ì€ í•­ë³µì´ ì•„ë‹ˆë¼ í•´ë°©ì´ì•¼. ë„ˆëŠ” ìžìœ ë¥¼ ì„ íƒí•œ ê±°ì•¼.",
                            companionship: "í˜¼ìžê°€ ì•„ë‹ˆë¼ëŠ” ê±¸ ì¸ì •í•˜ëŠ” ìˆœê°„, ì™¸ë¡œì›€ì€ ëë‚˜ê¸° ì‹œìž‘í•´.",
                            recognition: "ìžì‹ ì„ ì•„ëŠ” ê²ƒì€ ì„¸ìƒì„ ì•„ëŠ” ê²ƒë³´ë‹¤ ì–´ë ¤ì›Œ. ë„Œ ê°€ìž¥ ì–´ë ¤ìš´ ì¼ì„ í•´ëƒˆì–´.",
                            healing: "ì¹˜ìœ ëŠ” ì‹œê°„ì´ ì•„ë‹ˆë¼ ì¸ì •ì—ì„œ ì‹œìž‘ë¼. ì§€ê¸ˆ ë„ˆëŠ” ê·¸ ê¸¸ ìœ„ì— ìžˆì–´.",
                            love: "ìžê¸° ì‚¬ëž‘ì€ ëª¨ë“  ì‚¬ëž‘ì˜ ê·¼ì›ì´ì•¼. ê·¸ ìƒ˜ì„ ì°¾ì•˜êµ¬ë‚˜.",
                            future: "ê³¼ê±°ë¥¼ ì•ˆê³  ë¯¸ëž˜ë¡œ ê±¸ì–´ê°€ëŠ” ê²Œ ì§„ì§œ ì„±ìž¥ì´ì•¼. ë„Œ ê·¸ê±¸ í•˜ê³  ìžˆì–´.",
                            general: "ì—°ê²°ëœë‹¤ëŠ” ê±´ ëŠì–´ì§„ ê²Œ ì•„ë‹ˆì—ˆë‹¤ëŠ” ì¦ê±°ì•¼. ëŠ˜ ê±°ê¸° ìžˆì—ˆì–´, ì°¾ì§€ ëª»í–ˆì„ ë¿."
                        },
                        en: {
                            reconnection: "Being connected is proof it was never broken. It was always there, just undiscovered.",
                            forgiveness: "The moment you forgive yourself, all emotional doors begin to open again.",
                            acceptance: "Acceptance isn't surrender, it's liberation. You've chosen freedom.",
                            companionship: "The moment you acknowledge you're not alone, loneliness begins to end.",
                            recognition: "Knowing yourself is harder than knowing the world. You've done the hardest thing.",
                            healing: "Healing doesn't start with time, but with acknowledgment. You're on that path now.",
                            love: "Self-love is the source of all love. You've found that spring.",
                            future: "Walking into the future while embracing the past is real growth. You're doing that.",
                            general: "Being connected is proof it was never broken. It was always there, just undiscovered."
                        },
                        pt: {
                            reconnection: "Estar conectado Ã© prova de que nunca foi quebrado. Sempre esteve lÃ¡, apenas nÃ£o descoberto.",
                            forgiveness: "No momento em que vocÃª se perdoa, todas as portas emocionais comeÃ§am a se abrir novamente.",
                            acceptance: "AceitaÃ§Ã£o nÃ£o Ã© rendiÃ§Ã£o, Ã© libertaÃ§Ã£o. VocÃª escolheu a liberdade.",
                            companionship: "No momento em que vocÃª reconhece que nÃ£o estÃ¡ sozinho, a solidÃ£o comeÃ§ar a acabar.",
                            recognition: "Conhecer-se Ã© mais difÃ­cil que conhecer o mundo. VocÃª fez a coisa mais difÃ­cil.",
                            healing: "A cura nÃ£o comeÃ§a com o tempo, mas com o reconhecimento. VocÃª estÃ¡ nesse caminho agora.",
                            love: "O amor prÃ³prio Ã© a fonte de todo amor. VocÃª encontrou essa fonte.",
                            future: "Caminhar para o futuro enquanto abraÃ§a o passado Ã© crescimento real. VocÃª estÃ¡ fazendo isso.",
                            general: "Estar conectado Ã© prova de que nunca foi quebrado. Sempre esteve lÃ¡, apenas nÃ£o descoberto."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Mira", emoji: "ðŸ§‘â€ðŸŽ¨",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            reconnection: "ê·¸ ë¯¸ì•ˆí•¨ ìœ„ì—, ìƒˆë¡œìš´ ì„ ì„ ê·¸ë¦´ ìˆ˜ ìžˆì„ ê±°ì•¼. ì§„ì§œ ë„ˆì˜ ì–¼êµ´ë¡œ.",
                            forgiveness: "ìš©ì„œì˜ ìƒ‰ì€ ì—°í•œ í•˜ëŠ˜ìƒ‰ì´ì•¼. ëª¨ë“  ì–´ë‘ ì„ ë¶€ë“œëŸ½ê²Œ ê°ì‹¸ì£¼ëŠ” ìƒ‰.",
                            acceptance: "ë°›ì•„ë“¤ìž„ì˜ ë¶“ì§ˆì€ ê°€ìž¥ ìžì—°ìŠ¤ëŸ¬ì›Œ. ì–µì§€ë¡œ ê·¸ë¦¬ì§€ ì•Šì•„ë„ ë¼.",
                            companionship: "í•¨ê»˜ë¼ëŠ” ë§ì€ ìº”ë²„ìŠ¤ ìœ„ì—ì„œ ê°€ìž¥ ë”°ëœ»í•œ ìƒ‰ìœ¼ë¡œ ë²ˆì ¸.",
                            recognition: "ìžì‹ ì„ ì•Œì•„ë³´ëŠ” ìˆœê°„, ëª¨ë“  ìƒ‰ì´ ì œìžë¦¬ë¥¼ ì°¾ê¸° ì‹œìž‘í•´.",
                            healing: "ì¹˜ìœ ëŠ” ì§€ìš°ê°œê°€ ì•„ë‹ˆë¼ ìƒˆë¡œìš´ ë¬¼ê°ì´ì•¼. ë§ì¹ í•˜ë©° ì•„ë¦„ë‹¤ì›Œì§€ëŠ” ê±°ì•¼.",
                            love: "ìžê¸° ì‚¬ëž‘ì€ íŒ”ë ˆíŠ¸ì˜ ì²« ë²ˆì§¸ ìƒ‰ì´ì•¼. ëª¨ë“  ê·¸ë¦¼ì˜ ì‹œìž‘ì .",
                            future: "ê³¼ê±°ì™€ ë¯¸ëž˜ë¥¼ ìž‡ëŠ” ë¶“ì§ˆ, ê·¸ê²Œ ë°”ë¡œ ì§€ê¸ˆ ë„¤ê°€ ê·¸ë¦¬ê³  ìžˆëŠ” ì„ ì´ì•¼.",
                            general: "ê·¸ ë¯¸ì•ˆí•¨ ìœ„ì—, ìƒˆë¡œìš´ ì„ ì„ ê·¸ë¦´ ìˆ˜ ìžˆì„ ê±°ì•¼. ì§„ì§œ ë„ˆì˜ ì–¼êµ´ë¡œ."
                        },
                        en: {
                            reconnection: "On that apology, you'll be able to draw new lines. With your real face.",
                            forgiveness: "The color of forgiveness is light sky blue. A color that gently wraps all darkness.",
                            acceptance: "The brushstroke of acceptance is the most natural. You don't have to force it.",
                            companionship: "The word 'together' spreads as the warmest color on canvas.",
                            recognition: "The moment you recognize yourself, all colors begin to find their place.",
                            healing: "Healing isn't an eraser, it's new paint. It becomes beautiful by layering.",
                            love: "Self-love is the first color on the palette. The starting point of every painting.",
                            future: "The brushstroke connecting past and future, that's the line you're drawing now.",
                            general: "On that apology, you'll be able to draw new lines. With your real face."
                        },
                        pt: {
                            reconnection: "Sobre esse pedido de desculpas, vocÃª poderÃ¡ desenhar novas linhas. Com seu rosto real.",
                            forgiveness: "A cor do perdÃ£o Ã© azul claro do cÃ©u. Uma cor que envolve suavemente toda escuridÃ£o.",
                            acceptance: "A pincelada da aceitaÃ§Ã£o Ã© a mais natural. VocÃª nÃ£o precisa forÃ§ar.",
                            companionship: "A palavra 'junto' se espalha como a cor mais quente na tela.",
                            recognition: "No momento em que vocÃª se reconhece, todas as cores comeÃ§am a encontrar seu lugar.",
                            healing: "Cura nÃ£o Ã© borracha, Ã© tinta nova. Fica belo ao sobrepor camadas.",
                            love: "O amor prÃ³prio Ã© a primeira cor na paleta. O ponto de partida de toda pintura.",
                            future: "A pincelada conectando passado e futuro, essa Ã© a linha que vocÃª estÃ¡ desenhando agora.",
                            general: "Sobre esse pedido de desculpas, vocÃª poderÃ¡ desenhar novas linhas. Com seu rosto real."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            }
        ];
        
        let currentLanguage = 'en';
        let currentUser = null;
        let userResponse = '';
        let journeyStarted = false;
        let currentTypingElement = null;
        let typingIntervals = [];
        
        function typewriterEffect(element, text, speed = 80) {
            return new Promise((resolve) => {
                if (currentTypingElement) {
                    currentTypingElement.classList.remove('typing-cursor');
                }
                
                let i = 0;
                element.innerHTML = '';
                element.classList.add('typing-cursor');
                currentTypingElement = element;
                
                const typingInterval = setInterval(() => {
                    if (!document.contains(element)) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                        return;
                    }
                    
                    element.innerHTML += text.charAt(i);
                    i++;
                    
                    if (i % 10 === 0) {
                        scrollToFollowTyping(element);
                    }
                    
                    if (i === text.length) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                    }
                }, speed);
                
                typingIntervals.push(typingInterval);
            });
        }
        
        function clearAllTypingEffects() {
            typingIntervals.forEach(interval => clearInterval(interval));
            typingIntervals = [];
            
            if (currentTypingElement) {
                currentTypingElement.classList.remove('typing-cursor');
                currentTypingElement = null;
            }
        }
        
        function scrollToFollowTyping(element) {
            const mainContent = document.getElementById('mainContent');
            const elementRect = element.getBoundingClientRect();
            const containerRect = mainContent.getBoundingClientRect();
            
            if (elementRect.bottom > containerRect.bottom - 150) {
                const scrollTop = mainContent.scrollTop;
                const elementOffsetTop = element.offsetTop;
                const targetScroll = elementOffsetTop - (containerRect.height / 2);
                
                mainContent.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }
        
        function scrollToElement(element) {
            const mainContent = document.getElementById('mainContent');
            const elementOffsetTop = element.offsetTop;
            const containerHeight = mainContent.clientHeight;
            const targetScroll = elementOffsetTop - (containerHeight / 3);
            
            mainContent.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }
        
        function updateLanguageButtons(lang) {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateStaticTranslations(lang) {
            document.getElementById('logoSubtitle').textContent = translations[lang].logoSubtitle;
            document.getElementById('portalMainTitle').textContent = translations[lang].portalMainTitle;
            document.getElementById('portalSubtitle').textContent = translations[lang].portalSubtitle;
            document.getElementById('lightTitle').textContent = translations[lang].lightTitle;
            document.getElementById('finalTitle').textContent = translations[lang].finalTitle;
            document.getElementById('continueBtn').textContent = translations[lang].continueBtn;
            document.getElementById('restartBtn').textContent = translations[lang].restartBtn;
            document.getElementById('userTextarea').placeholder = translations[lang].inputPlaceholder;
        }
        
        function changeLanguage(lang) {
            if (!translations[lang] || currentLanguage === lang) return;
            
            currentLanguage = lang;
            updateLanguageButtons(lang);
            updateStaticTranslations(lang);
            
            if (journeyStarted) {
                resetJourney();
                setTimeout(() => {
                    startPortalSequence();
                }, 1000);
            }
        }
        
        function resetJourney() {
            clearAllTypingEffects();
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            
            const sectionsToReset = [
                'portalIntroSection', 'characterResponsesSection', 
                'lightMessageSection', 'portalQuestionSection',
                'userInputSection', 'userReactionsSection', 'finalSection'
            ];
            
            sectionsToReset.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('show');
                    section.style.opacity = '0';
                    if (sectionId === 'characterResponsesSection' || 
                        sectionId === 'userInputSection' || 
                        sectionId === 'userReactionsSection') {
                        section.innerHTML = '';
                    }
                }
            });
            
            document.getElementById('portalIntro').innerHTML = '';
            document.getElementById('lightMessage').innerHTML = '';
            document.getElementById('portalQuestion').innerHTML = '';
            document.getElementById('finalMessage').innerHTML = '';
            
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            document.getElementById('mainContent').scrollTop = 0;
            userResponse = '';
            currentTypingElement = null;
        }
        
        function setupLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    changeLanguage(this.dataset.lang);
                });
            });
        }
        
        function setupTextareaAutoResize() {
            const textarea = document.getElementById('userTextarea');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 96) + 'px';
            });
        }
        
        function setupInputEvents() {
            const userTextarea = document.getElementById('userTextarea');
            
            userTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const inputValue = this.value.trim();
                    
                    if (inputValue) {
                        processUserInput(inputValue);
                    }
                }
            });
            
            document.getElementById('continueBtn').addEventListener('click', function() {
                const nextMessage = currentLanguage === 'ko' ? 
                    'Portal 25ê°€ ê³§ ì¤€ë¹„ë©ë‹ˆë‹¤!' :
                    currentLanguage === 'en' ? 
                    'Portal 25 will be ready soon!' :
                    'Portal 25 estarÃ¡ pronto em breve!';
                alert(nextMessage);
            });
            
            document.getElementById('restartBtn').addEventListener('click', function() {
                const confirmMessage = currentLanguage === 'ko' ? 
                    'Portal 24ë¥¼ ë‹¤ì‹œ ì‹œìž‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' :
                    currentLanguage === 'en' ? 
                    'Do you want to restart Portal 24?' :
                    'Deseja reiniciar o Portal 24?';
                
                if (confirm(confirmMessage)) {
                    resetJourney();
                    setTimeout(() => {
                        startPortalSequence();
                    }, 1000);
                }
            });
        }
        
        async function processUserInput(inputText) {
            userResponse = inputText;
            
            if (firebaseInitialized && db) {
                try {
                    await db.collection("temarix_v3_respostas").add({
                        uid: memoryStorage.mockUser.uid,
                        email: memoryStorage.mockUser.email,
                        portal: "v3-24",
                        resposta: inputText,
                        data: firebase.firestore.Timestamp.now(),
                        idioma: currentLanguage
                    });
                    console.log('Response saved to Firestore');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                }
            } else {
                console.log('Firebase not available, saved locally:', inputText);
                localStorage.setItem('temarix_v3_last_response', JSON.stringify({
                    portal: "v3-24",
                    resposta: inputText,
                    data: new Date().toISOString(),
                    idioma: currentLanguage
                }));
            }
            
            disableUserInput();
            showUserResponse(inputText);
            
            setTimeout(() => {
                showUserReactions(inputText);
            }, 1000);
        }
        
        function disableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = true;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].waitingMessage;
        }
        
        function enableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            setTimeout(() => {
                userTextarea.focus();
            }, 100);
        }
        
        function showUserResponse(text) {
            const inputSection = document.getElementById('userInputSection');
            const userDiv = document.createElement('div');
            userDiv.className = 'user-response';
            const youLabel = translations[currentLanguage].youLabel;
            userDiv.innerHTML = '<strong>' + youLabel + ':</strong> "' + text + '"';
            inputSection.appendChild(userDiv);
            inputSection.classList.add('show');
            
            setTimeout(() => {
                scrollToElement(inputSection);
            }, 100);
        }
        
        async function showUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            reactionsSection.classList.add('show');
            
            for (let i = 0; i < responseCharacters.length; i++) {
                const char = responseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < responseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showFinalSection();
            }, 2000);
        }
        
        async function showFinalSection() {
            const finalSection = document.getElementById('finalSection');
            const finalMessage = document.getElementById('finalMessage');
            
            finalSection.classList.add('show');
            
            const messageText = translations[currentLanguage].finalMessage;
            await typewriterEffect(finalMessage, messageText, 50);
            
            setTimeout(() => {
                scrollToElement(finalSection);
            }, 500);
        }
        
        function initializeTemarix() {
            console.log('Temarix V3 Portal 24 initialized');
            
            setupLanguageButtons();
            setupTextareaAutoResize();
            setupInputEvents();
            
            journeyStarted = true;
            
            setTimeout(() => {
                startPortalSequence();
            }, 1000);
        }
        
        function startPortalSequence() {
            setTimeout(() => {
                showIntro();
            }, 1000);
        }
        
        async function showIntro() {
            const introSection = document.getElementById('portalIntroSection');
            const introElement = document.getElementById('portalIntro');
            
            introSection.classList.add('show');
            
            await typewriterEffect(introElement, translations[currentLanguage].portalIntro, 60);
            
            setTimeout(() => {
                showCharacterResponses();
            }, 2000);
        }
        
        async function showCharacterResponses() {
            const responseSection = document.getElementById('characterResponsesSection');
            responseSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                responseSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showLightMessage();
            }, 2000);
        }
        
        async function showLightMessage() {
            const lightSection = document.getElementById('lightMessageSection');
            const lightMessageEl = document.getElementById('lightMessage');
            
            lightSection.classList.add('show');
            
            await typewriterEffect(lightMessageEl, translations[currentLanguage].lightMessage, 60);
            
            setTimeout(() => {
                showQuestion();
            }, 2000);
        }
        
        async function showQuestion() {
            const questionSection = document.getElementById('portalQuestionSection');
            const questionEl = document.getElementById('portalQuestion');
            
            questionSection.classList.add('show');
            
            await typewriterEffect(questionEl, translations[currentLanguage].portalQuestion, 50);
            
            setTimeout(() => {
                enableUserInput();
            }, 1500);
        }
        
        function getLanguageFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');
            return lang && translations[lang] ? lang : 'en';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Temarix V3 Portal 24 DOM loaded');
            
            initializeFirebase();
            
            currentLanguage = getLanguageFromURL();
            
            currentUser = { 
                uid: 'user-auto-' + Date.now(),
                email: 'auto@temarix.com'
            };
            
            memoryStorage.mockUser = currentUser;
            
            updateStaticTranslations(currentLanguage);
            updateLanguageButtons(currentLanguage);
            initializeTemarix();
        });
    </script>
</body>
</html>