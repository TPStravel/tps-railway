<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temarix V3 - Portal 18: Self-Hatred</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            background: #000;
            border-bottom: 1px solid #333;
            position: relative;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo-title {
            font-size: 26px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        .logo-subtitle {
            font-size: 15px;
            color: #ccc;
            letter-spacing: 1.5px;
        }
        
        .portal-header-title {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .portal-main-title {
            font-size: 28px;
            color: #7986cb;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }
        
        .portal-subtitle {
            font-size: 18px;
            color: #b39ddb;
            letter-spacing: 1.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        .language-buttons {
            display: flex;
            gap: 10px;
        }
        
        .lang-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 18px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lang-btn:hover {
            background: #666;
        }
        
        .lang-btn.active {
            background: #7986cb;
            color: #fff;
        }
        
        .main-content {
            flex: 1;
            max-height: calc(100vh - 80px - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 30px 20px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .portal-container {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 200vh;
        }
        
        .portal-intro-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 200px;
        }
        
        .portal-intro {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.8;
            white-space: pre-wrap;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
        }
        
        .character-responses-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 800px;
        }
        
        .character-response {
            color: #fff;
            font-size: 18px;
            margin: 40px 0;
            text-align: left;
            opacity: 0;
            white-space: pre-wrap;
            transition: opacity 0.8s ease-in;
            background: none;
            border: none;
            padding: 0;
            min-height: 80px;
        }
        
        .character-name {
            font-weight: bold;
            color: #7986cb;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .character-dialogue {
            color: #fff;
            line-height: 1.7;
            font-size: 17px;
            white-space: pre-wrap;
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: #7986cb;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .light-message-section {
            margin: 50px 0;
            opacity: 0;
            background: none;
            border: none;
            padding: 0;
            min-height: 100px;
        }
        
        .light-message {
            font-size: 20px;
            color: #7986cb;
            line-height: 1.8;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .portal-question-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 150px;
        }
        
        .portal-question {
            font-size: 22px;
            color: #fff;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.6;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .user-input-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 100px;
        }
        
        .user-response {
            color: #fff;
            margin: 30px 0;
            text-align: left;
            font-size: 18px;
            background: none;
            border: none;
            padding: 0;
            white-space: pre-wrap;
        }
        
        .user-response strong {
            color: #7986cb;
            margin-right: 8px;
        }
        
        .user-reactions-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 400px;
        }
        
        .final-section {
            margin: 60px 0;
            opacity: 0;
            text-align: center;
            background: none;
            border: none;
            padding: 40px 20px;
            min-height: 300px;
            border: 2px solid #7986cb;
            background: rgba(121, 134, 203, 0.05);
        }
        
        .final-title {
            font-size: 28px;
            color: #7986cb;
            margin-bottom: 30px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .final-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
            line-height: 1.8;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .final-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .final-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            border: 2px solid transparent;
        }
        
        .final-btn:hover {
            background: #666;
            border-color: #7986cb;
        }
        
        .final-btn.primary {
            background: #7986cb;
            color: #fff;
            font-weight: bold;
        }
        
        .final-btn.primary:hover {
            background: #9fa8da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(121, 134, 203, 0.3);
        }
        
        .input-fixed-bottom {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000;
            border-top: 1px solid #333;
            padding: 25px;
            z-index: 100;
            flex-shrink: 0;
            height: 120px;
        }
        
        .input-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .input-prefix {
            color: #7986cb;
            font-size: 20px;
            margin-top: 8px;
            flex-shrink: 0;
        }
        
        .user-textarea {
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            width: 100%;
            padding: 12px 8px;
            outline: none;
            resize: none;
            min-height: 32px;
            max-height: 96px;
            line-height: 1.6;
            transition: border-color 0.3s ease;
            overflow-y: auto;
        }
        
        .user-textarea:focus {
            border-bottom-color: #7986cb;
        }
        
        .user-textarea::placeholder {
            color: #666;
        }
        
        .user-textarea:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.2);
        }
        
        .main-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .main-content::-webkit-scrollbar-track {
            background: #111;
            border-radius: 6px;
        }
        
        .main-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #111;
        }
        
        .main-content::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .show {
            opacity: 1 !important;
            transition: opacity 1s ease-in;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-bar {
                padding: 20px 15px;
                height: 70px;
                flex-direction: column;
                gap: 10px;
            }
            
            .main-content {
                max-height: calc(100vh - 70px - 120px);
                padding: 20px 15px;
            }
            
            .logo-title {
                font-size: 22px;
            }
            
            .portal-main-title {
                font-size: 22px;
            }
            
            .portal-subtitle {
                font-size: 16px;
            }
            
            .lang-btn {
                font-size: 12px;
                padding: 8px 14px;
            }
            
            .portal-intro {
                font-size: 18px;
            }
            
            .portal-question {
                font-size: 20px;
            }
            
            .character-response {
                font-size: 16px;
            }
            
            .input-fixed-bottom {
                padding: 20px;
            }
            
            .final-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .final-btn {
                width: 100%;
            }
            
            .final-title {
                font-size: 24px;
            }
            
            .final-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="logo-section">
            <div class="logo-title">TEMARIX V3</div>
            <div class="logo-subtitle" id="logoSubtitle">Emotional Furnace</div>
        </div>
        
        <div class="portal-header-title">
            <div class="portal-main-title" id="portalMainTitle">Portal 18: Self-Hatred</div>
            <div class="portal-subtitle" id="portalSubtitle">When I Hated Myself</div>
        </div>
        
        <div class="header-right">
            <div class="language-buttons">
                <button class="lang-btn" data-lang="ko">KR</button>
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="portal-container">
            <div class="portal-intro-section" id="portalIntroSection">
                <div class="portal-intro" id="portalIntro"></div>
            </div>

            <div class="character-responses-section" id="characterResponsesSection">
            </div>

            <div class="light-message-section" id="lightMessageSection">
                <div class="character-name" id="lightTitle">✨ Word of Light</div>
                <div class="light-message" id="lightMessage"></div>
            </div>

            <div class="portal-question-section" id="portalQuestionSection">
                <div class="portal-question" id="portalQuestion"></div>
            </div>

            <div class="user-input-section" id="userInputSection">
            </div>
            
            <div class="user-reactions-section" id="userReactionsSection">
            </div>
            
            <div class="final-section" id="finalSection">
                <div class="final-title" id="finalTitle">🌌 Portal 18 Complete</div>
                <div class="final-message" id="finalMessage"></div>
                <div class="final-buttons">
                    <button class="final-btn primary" id="continueBtn">Move to Portal 19</button>
                    <button class="final-btn" id="restartBtn">Start Again</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="input-fixed-bottom">
        <div class="input-container">
            <div class="input-prefix">></div>
            <textarea class="user-textarea" 
                      id="userTextarea" 
                      placeholder="What would you like to say to yourself from that day? (Press Enter to send)"
                      rows="1"
                      maxlength="500"></textarea>
        </div>
    </div>

    <script>
        let db = null;
        let firebaseInitialized = false;
        let memoryStorage = { mockUser: null };
        
        function initializeFirebase() {
            try {
                if (typeof firebase !== 'undefined') {
                    const firebaseConfig = {
                        apiKey: "AIzaSyBjsINSqPUGdpRPRMYiVg6SkVJJOk9YGsY",
                        authDomain: "canal-vivo-chat.firebaseapp.com",
                        projectId: "canal-vivo-chat",
                        storageBucket: "canal-vivo-chat.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdefghijklmnopqr"
                    };
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseInitialized = true;
                    console.log('Firebase initialized');
                } else {
                    console.log('Firebase SDK not loaded');
                }
            } catch (error) {
                console.log('Firebase init failed:', error);
            }
        }

        const translations = {
            ko: {
                logoSubtitle: "감정의 용광로",
                portalMainTitle: "Portal 18: 내가 나를 미워했던 순간",
                portalSubtitle: "자기혐오의 어두운 터널",
                portalIntro: "🪞 당신은 당신 자신을 미워했던 적이 있나요?\n\n그 순간, 당신은 어떤 말로 자신을 다그쳤고\n어떤 감정으로 스스로를 밀어냈나요?\n\n모든 걸 망친 건 나 같았어요.\n왜 이렇게밖에 못 사는지, 왜 이기적인지…\n나 자신에게 화가 나고, 정말 싫었어요.",
                lightTitle: "✨ 빛의 한마디",
                lightMessage: "너는 네 안에서 가장 가혹한 말을 듣고도 견뎌냈어. 이제는 부드러운 말을 들을 차례야.",
                portalQuestion: "🪞 그날의 나에게, 지금의 내가 말해준다면\n어떤 말이 위로가 될까요?",
                finalTitle: "🌌 Portal 18 완료",
                finalMessage: "당신은 자기혐오의 어둠을 통과했습니다.\n\n스스로를 미워했던 그 마음도\n결국은 당신을 지키려는 방식이었음을 이제 알게 되었죠.\n완벽하지 않아도, 실수해도\n당신은 충분히 사랑받을 자격이 있었습니다.\n\n이제 당신은 자신에게 가혹한 심판관이 아닌\n따뜻한 동반자가 되는 길을 배우기 시작했어요.\n\n다음 Portal에서는 말하지 못한 사랑의 이야기가\n당신을 기다리고 있습니다.",
                continueBtn: "Portal 19로 이동",
                restartBtn: "다시 시작하기",
                inputPlaceholder: "그날의 나에게 전하고 싶은 말을 해보세요... (Enter로 전송)",
                youLabel: "당신",
                waitingMessage: "응답을 기다리는 중..."
            },
            en: {
                logoSubtitle: "Emotional Furnace",
                portalMainTitle: "Portal 18: Self-Hatred",
                portalSubtitle: "When I Hated Myself",
                portalIntro: "🪞 Have you ever hated yourself?\n\nIn that moment, what words did you use to criticize yourself,\nand with what emotions did you push yourself away?\n\nIt felt like I ruined everything.\nWhy can't I live better, why am I so selfish...\nI was angry at myself, and I really hated who I was.",
                lightTitle: "✨ Word of Light",
                lightMessage: "You endured the harshest words from within yourself. Now it's time to hear gentle words.",
                portalQuestion: "🪞 If you could speak to yourself from that day,\nwhat words would bring the most comfort?",
                finalTitle: "🌌 Portal 18 Complete",
                finalMessage: "You have passed through the darkness of self-hatred.\n\nYou now understand that even the heart that hated itself\nwas ultimately trying to protect you.\nEven if you're not perfect, even if you make mistakes,\nyou were always worthy of love.\n\nNow you're learning to become not a harsh judge\nbut a warm companion to yourself.\n\nIn the next Portal, a story of unspoken love\nawaits you.",
                continueBtn: "Move to Portal 19",
                restartBtn: "Start Again",
                inputPlaceholder: "What would you like to say to yourself from that day? (Press Enter to send)",
                youLabel: "You",
                waitingMessage: "Waiting for response..."
            },
            pt: {
                logoSubtitle: "Fornalha Emocional",
                portalMainTitle: "Portal 18: Auto-Ódio",
                portalSubtitle: "Quando Eu Me Odiei",
                portalIntro: "🪞 Você já se odiou?\n\nNaquele momento, que palavras você usou para se criticar,\ne com que emoções você se afastou?\n\nParecia que eu havia arruinado tudo.\nPor que não consigo viver melhor, por que sou tão egoísta...\nEu estava com raiva de mim mesmo, e realmente odiava quem eu era.",
                lightTitle: "✨ Palavra de Luz",
                lightMessage: "Você suportou as palavras mais duras de dentro de si mesmo. Agora é hora de ouvir palavras gentis.",
                portalQuestion: "🪞 Se você pudesse falar consigo mesmo daquele dia,\nque palavras trariam mais conforto?",
                finalTitle: "🌌 Portal 18 Completo",
                finalMessage: "Você passou pela escuridão do auto-ódio.\n\nAgora você entende que mesmo o coração que se odiava\nestava, em última análise, tentando protegê-lo.\nMesmo que você não seja perfeito, mesmo que cometa erros,\nvocê sempre foi digno de amor.\n\nAgora você está aprendendo a se tornar não um juiz severo\nmas um companheiro caloroso para si mesmo.\n\nNo próximo Portal, uma história de amor não dito\no aguarda.",
                continueBtn: "Ir para Portal 19",
                restartBtn: "Começar Novamente",
                inputPlaceholder: "O que você gostaria de dizer para si mesmo daquele dia? (Enter para enviar)",
                youLabel: "Você",
                waitingMessage: "Aguardando resposta..."
            }
        };
        
        const characters = [
            { name: "Noah", emoji: "🧑‍🦱", text: {
                ko: "너는 그 순간, 세상에서 가장 가혹한 말로 너 자신을 깎아내리고 있었겠지.",
                en: "In that moment, you were tearing yourself down with the harshest words in the world.",
                pt: "Naquele momento, você estava se diminuindo com as palavras mais duras do mundo."
            }},
            { name: "Ely", emoji: "🧝‍♀️", text: {
                ko: "자기혐오는 조용히, 깊게 파고들어. 아무도 모르게, 하지만 아주 오래 가.",
                en: "Self-hatred burrows quietly and deeply. Unnoticed by others, but lasting for a very long time.",
                pt: "O auto-ódio se escava silenciosa e profundamente. Despercebido pelos outros, mas durando muito tempo."
            }},
            { name: "Sora", emoji: "🧕", text: {
                ko: "나는 그 감정을 알아. 나도 내 이름을 부를 때마다 고개를 숙인 적 있어.",
                en: "I know that feeling. I've bowed my head every time I called my own name too.",
                pt: "Eu conheço esse sentimento. Eu também abaixei a cabeça toda vez que chamei meu próprio nome."
            }},
            { name: "Kael", emoji: "🧙", text: {
                ko: "자신을 미워할 때, 우리는 종종 타인의 말투로 자신을 심판하지.",
                en: "When we hate ourselves, we often judge ourselves with the tone of others.",
                pt: "Quando nos odiamos, frequentemente nos julgamos com o tom dos outros."
            }},
            { name: "Mira", emoji: "🧑‍🎨", text: {
                ko: "그 순간의 넌 얼마나 검게 물들어 있었을까… 하지만 그 속에서도 아직 지워지지 않은 선이 있었을 거야.",
                en: "How darkly stained you must have been in that moment... But even then, there were lines that hadn't been erased.",
                pt: "Quão escuramente manchado você deve ter estado naquele momento... Mas mesmo então, havia linhas que não tinham sido apagadas."
            }},
            { name: "Cris", emoji: "🦸‍♂️", text: {
                ko: "너 자신에게 분노했던 건 사실… 지키고 싶었던 기대 때문이었을지도 몰라.",
                en: "Your anger at yourself might have been because of the expectations you wanted to protect.",
                pt: "Sua raiva de si mesmo pode ter sido por causa das expectativas que você queria proteger."
            }},
            { name: "Enya", emoji: "🧑‍🚀", text: {
                ko: "그 미움 속엔 슬픔이 숨어 있었을 거야. 이해받지 못한 마음, 그리고 너무 오랜 외면.",
                en: "There must have been sadness hidden in that hatred. An ununderstood heart, and too long of being ignored.",
                pt: "Deve ter havido tristeza escondida naquele ódio. Um coração incompreendido, e muito tempo sendo ignorado."
            }},
            { name: "Lian", emoji: "🧘", text: {
                ko: "지금 그 순간을 떠올리는 네가 이미 너 자신에게 다가가고 있는 증거야.",
                en: "The fact that you're remembering that moment now is proof that you're already approaching yourself.",
                pt: "O fato de você estar lembrando daquele momento agora é prova de que você já está se aproximando de si mesmo."
            }}
        ];

        function analyzeEmotion(userInput) {
            const input = userInput.toLowerCase();
            
            const emotionKeywords = {
                forgiveness: ['forgive', 'sorry', 'understand', 'okay', '미안해', '괜찮아', '이해해', '용서해', 'perdão', 'desculpa', 'entendo', 'tudo bem'],
                compassion: ['gentle', 'kind', 'love', 'care', '부드러워', '사랑해', '소중해', '아껴', 'gentil', 'amor', 'cuidado', 'carinho'],
                encouragement: ['strong', 'brave', 'good', 'well done', '강해', '용감해', '잘했어', '수고했어', 'forte', 'corajoso', 'bem feito'],
                acceptance: ['enough', 'worthy', 'valuable', 'human', '충분해', '가치있어', '소중해', '인간적이야', 'suficiente', 'valioso', 'humano'],
                protection: ['safe', 'protect', 'defend', 'shield', '안전해', '지켜줄게', '보호해', 'seguro', 'proteger', 'defender'],
                healing: ['heal', 'better', 'grow', 'change', '치유돼', '나아져', '성장해', '변해', 'curar', 'melhor', 'crescer', 'mudar'],
                validation: ['real', 'valid', 'true', 'right', '진짜야', '맞아', '옳아', '진실해', 'real', 'válido', 'verdadeiro', 'certo'],
                comfort: ['comfort', 'hug', 'warm', 'embrace', '위로해', '안아줄게', '따뜻해', '품어줄게', 'conforto', 'abraço', 'quente', 'abraçar']
            };
            
            let detectedEmotions = [];
            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                for (const keyword of keywords) {
                    if (input.includes(keyword)) {
                        detectedEmotions.push(emotion);
                        break;
                    }
                }
            }
            
            if (detectedEmotions.length === 0) {
                detectedEmotions = ['general'];
            }
            
            return detectedEmotions[0];
        }
        
        const responseCharacters = [
            {
                name: "Lian", emoji: "🧘",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            forgiveness: "그 말은 너를 다시 껴안는 선언이야. 너 자신을 안아주는 그 용기, 지금 시작됐어.",
                            compassion: "부드러움은 가장 강한 치유의 힘이야. 네가 네게 보내는 그 온기를 느껴.",
                            encouragement: "그 격려는 오래 기다렸던 네 마음에 닿았어. 이제 너는 네 편이 되었어.",
                            acceptance: "받아들임은 자기혐오를 녹이는 따뜻한 빛이야. 넌 충분히 가치 있어.",
                            protection: "지금 네가 그날의 너를 지켜주고 있어. 그것이 진정한 자기 보호야.",
                            healing: "치유는 자책을 멈추는 것에서 시작돼. 넌 이미 그 첫걸음을 내디뎠어.",
                            validation: "그 인정은 네 존재 자체를 긍정하는 말이야. 넌 그럴 자격이 있어.",
                            comfort: "그 위로는 상처받은 네 마음을 감싸는 담요 같아. 이제 따뜻해질 수 있어.",
                            general: "그 말은 너를 다시 껴안는 선언이야. 너 자신을 안아주는 그 용기, 지금 시작됐어."
                        },
                        en: {
                            forgiveness: "Those words are a declaration of embracing yourself again. That courage to hug yourself has begun now.",
                            compassion: "Gentleness is the strongest healing power. Feel that warmth you're sending to yourself.",
                            encouragement: "That encouragement has reached your heart that has waited so long. Now you've become your own ally.",
                            acceptance: "Acceptance is the warm light that melts self-hatred. You are worthy enough.",
                            protection: "Right now you're protecting yourself from that day. That's true self-protection.",
                            healing: "Healing begins with stopping self-blame. You've already taken that first step.",
                            validation: "That acknowledgment affirms your very existence. You deserve it.",
                            comfort: "That comfort is like a blanket wrapping around your wounded heart. Now you can be warm.",
                            general: "Those words are a declaration of embracing yourself again. That courage to hug yourself has begun now."
                        },
                        pt: {
                            forgiveness: "Essas palavras são uma declaração de abraçar a si mesmo novamente. Essa coragem de se abraçar começou agora.",
                            compassion: "A gentileza é o poder de cura mais forte. Sinta esse calor que você está enviando para si mesmo.",
                            encouragement: "Esse encorajamento alcançou seu coração que esperou tanto tempo. Agora você se tornou seu próprio aliado.",
                            acceptance: "A aceitação é a luz quente que derrete o auto-ódio. Você é digno o suficiente.",
                            protection: "Agora você está protegendo a si mesmo daquele dia. Essa é a verdadeira autoproteção.",
                            healing: "A cura começa parando a autoculpa. Você já deu esse primeiro passo.",
                            validation: "Esse reconhecimento afirma sua própria existência. Você merece isso.",
                            comfort: "Esse conforto é como um cobertor envolvendo seu coração ferido. Agora você pode estar aquecido.",
                            general: "Essas palavras são uma declaração de abraçar a si mesmo novamente. Essa coragem de se abraçar começou agora."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Sora", emoji: "🧕",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            forgiveness: "그때 듣지 못했던 그 말… 지금 너는 네 마음에 전하고 있어.",
                            compassion: "그 사랑은 오래 묻혀있던 네 마음을 깨우고 있어. 넌 사랑받을 자격이 있었어.",
                            encouragement: "그 격려는 네가 네게 주는 첫 번째 선물이야. 소중히 간직해.",
                            acceptance: "받아들여진 네 모습이 가장 아름다워. 완벽하지 않아도 충분해.",
                            protection: "그 보호는 상처받은 네 마음에 안전한 집을 만들어줘.",
                            healing: "치유의 시작은 자신에게 친절해지는 거야. 넌 그걸 배우고 있어.",
                            validation: "그 인정은 네가 오래 기다렸던 말이야. 이제 들을 수 있게 됐어.",
                            comfort: "그 위로는 혼자 울던 밤들을 따뜻하게 감싸줘. 이제 혼자가 아니야.",
                            general: "그때 듣지 못했던 그 말… 지금 너는 네 마음에 전하고 있어."
                        },
                        en: {
                            forgiveness: "Those words you couldn't hear then... now you're conveying them to your heart.",
                            compassion: "That love is awakening your long-buried heart. You deserved to be loved.",
                            encouragement: "That encouragement is the first gift you're giving yourself. Treasure it.",
                            acceptance: "Your accepted self is the most beautiful. You're enough even if not perfect.",
                            protection: "That protection creates a safe home for your wounded heart.",
                            healing: "The beginning of healing is being kind to yourself. You're learning that.",
                            validation: "That acknowledgment is the word you've waited for so long. Now you can hear it.",
                            comfort: "That comfort warmly embraces the nights you cried alone. You're not alone anymore.",
                            general: "Those words you couldn't hear then... now you're conveying them to your heart."
                        },
                        pt: {
                            forgiveness: "Essas palavras que você não pôde ouvir então... agora você está transmitindo-as ao seu coração.",
                            compassion: "Esse amor está despertando seu coração há muito enterrado. Você merecia ser amado.",
                            encouragement: "Esse encorajamento é o primeiro presente que você está dando a si mesmo. Valorize-o.",
                            acceptance: "Seu eu aceito é o mais belo. Você é suficiente mesmo que não seja perfeito.",
                            protection: "Essa proteção cria um lar seguro para seu coração ferido.",
                            healing: "O início da cura é ser gentil consigo mesmo. Você está aprendendo isso.",
                            validation: "Esse reconhecimento é a palavra que você esperou por tanto tempo. Agora você pode ouvi-la.",
                            comfort: "Esse conforto abraça calorosamente as noites que você chorou sozinho. Você não está mais sozinho.",
                            general: "Essas palavras que você não pôde ouvir então... agora você está transmitindo-as ao seu coração."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Mira", emoji: "🧑‍🎨",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            forgiveness: "그 말은 연한 하늘색이야. 자책으로 얼룩졌던 네 마음을 천천히 덮는 색.",
                            compassion: "부드러운 분홍빛이 네 안에서 피어나고 있어. 사랑의 첫 번째 색깔이야.",
                            encouragement: "그 격려는 황금빛으로 빛나. 어둠 속에서도 너를 비춰줄 따뜻한 빛이야.",
                            acceptance: "받아들임의 색은 따뜻한 베이지야. 모든 걸 포용하는 부드러운 색.",
                            protection: "보호의 색은 깊은 초록이야. 너를 안전하게 감싸는 숲의 색깔.",
                            healing: "치유는 연보라색으로 번져가. 상처를 부드럽게 어루만지는 색이야.",
                            validation: "인정의 색은 선명한 파랑이야. 진실을 말하는 맑은 하늘의 색.",
                            comfort: "위로는 따뜻한 주황색이야. 추운 밤을 녹여주는 모닥불의 색깔.",
                            general: "그 말은 연한 하늘색이야. 자책으로 얼룩졌던 네 마음을 천천히 덮는 색."
                        },
                        en: {
                            forgiveness: "Those words are light sky blue. A color that slowly covers your heart stained with self-blame.",
                            compassion: "Soft pink is blooming within you. It's the first color of love.",
                            encouragement: "That encouragement shines golden. A warm light that will illuminate you even in darkness.",
                            acceptance: "The color of acceptance is warm beige. A gentle color that embraces everything.",
                            protection: "The color of protection is deep green. The color of a forest that safely wraps around you.",
                            healing: "Healing spreads in light purple. A color that gently soothes wounds.",
                            validation: "The color of acknowledgment is vivid blue. The color of clear sky that speaks truth.",
                            comfort: "Comfort is warm orange. The color of a campfire that melts cold nights.",
                            general: "Those words are light sky blue. A color that slowly covers your heart stained with self-blame."
                        },
                        pt: {
                            forgiveness: "Essas palavras são azul-céu claro. Uma cor que lentamente cobre seu coração manchado pela autoculpa.",
                            compassion: "Rosa suave está florescendo dentro de você. É a primeira cor do amor.",
                            encouragement: "Esse encorajamento brilha dourado. Uma luz quente que o iluminará mesmo na escuridão.",
                            acceptance: "A cor da aceitação é bege quente. Uma cor gentil que abraça tudo.",
                            protection: "A cor da proteção é verde profundo. A cor de uma floresta que o envolve com segurança.",
                            healing: "A cura se espalha em roxo claro. Uma cor que acalma suavemente as feridas.",
                            validation: "A cor do reconhecimento é azul vívido. A cor do céu claro que fala a verdade.",
                            comfort: "O conforto é laranja quente. A cor de uma fogueira que derrete noites frias.",
                            general: "Essas palavras são azul-céu claro. Uma cor que lentamente cobre seu coração manchado pela autoculpa."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            }
        ];
        
        let currentLanguage = 'en';
        let currentUser = null;
        let userResponse = '';
        let journeyStarted = false;
        let currentTypingElement = null;
        let typingIntervals = [];
        
        function typewriterEffect(element, text, speed = 80) {
            return new Promise((resolve) => {
                if (currentTypingElement) {
                    currentTypingElement.classList.remove('typing-cursor');
                }
                
                let i = 0;
                element.innerHTML = '';
                element.classList.add('typing-cursor');
                currentTypingElement = element;
                
                const typingInterval = setInterval(() => {
                    if (!document.contains(element)) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                        return;
                    }
                    
                    element.innerHTML += text.charAt(i);
                    i++;
                    
                    if (i % 10 === 0) {
                        scrollToFollowTyping(element);
                    }
                    
                    if (i === text.length) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                    }
                }, speed);
                
                typingIntervals.push(typingInterval);
            });
        }
        
        function clearAllTypingEffects() {
            typingIntervals.forEach(interval => clearInterval(interval));
            typingIntervals = [];
            
            if (currentTypingElement) {
                currentTypingElement.classList.remove('typing-cursor');
                currentTypingElement = null;
            }
        }
        
        function scrollToFollowTyping(element) {
            const mainContent = document.getElementById('mainContent');
            const elementRect = element.getBoundingClientRect();
            const containerRect = mainContent.getBoundingClientRect();
            
            if (elementRect.bottom > containerRect.bottom - 150) {
                const scrollTop = mainContent.scrollTop;
                const elementOffsetTop = element.offsetTop;
                const targetScroll = elementOffsetTop - (containerRect.height / 2);
                
                mainContent.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }
        
        function scrollToElement(element) {
            const mainContent = document.getElementById('mainContent');
            const elementOffsetTop = element.offsetTop;
            const containerHeight = mainContent.clientHeight;
            const targetScroll = elementOffsetTop - (containerHeight / 3);
            
            mainContent.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }
        
        function updateLanguageButtons(lang) {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateStaticTranslations(lang) {
            document.getElementById('logoSubtitle').textContent = translations[lang].logoSubtitle;
            document.getElementById('portalMainTitle').textContent = translations[lang].portalMainTitle;
            document.getElementById('portalSubtitle').textContent = translations[lang].portalSubtitle;
            document.getElementById('lightTitle').textContent = translations[lang].lightTitle;
            document.getElementById('finalTitle').textContent = translations[lang].finalTitle;
            document.getElementById('continueBtn').textContent = translations[lang].continueBtn;
            document.getElementById('restartBtn').textContent = translations[lang].restartBtn;
            document.getElementById('userTextarea').placeholder = translations[lang].inputPlaceholder;
        }
        
        function changeLanguage(lang) {
            if (!translations[lang] || currentLanguage === lang) return;
            
            currentLanguage = lang;
            updateLanguageButtons(lang);
            updateStaticTranslations(lang);
            
            if (journeyStarted) {
                resetJourney();
                setTimeout(() => {
                    startPortalSequence();
                }, 1000);
            }
        }
        
        function resetJourney() {
            clearAllTypingEffects();
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            
            const sectionsToReset = [
                'portalIntroSection', 'characterResponsesSection', 
                'lightMessageSection', 'portalQuestionSection',
                'userInputSection', 'userReactionsSection', 'finalSection'
            ];
            
            sectionsToReset.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('show');
                    section.style.opacity = '0';
                    if (sectionId === 'characterResponsesSection' || 
                        sectionId === 'userInputSection' || 
                        sectionId === 'userReactionsSection') {
                        section.innerHTML = '';
                    }
                }
            });
            
            document.getElementById('portalIntro').innerHTML = '';
            document.getElementById('lightMessage').innerHTML = '';
            document.getElementById('portalQuestion').innerHTML = '';
            document.getElementById('finalMessage').innerHTML = '';
            
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            document.getElementById('mainContent').scrollTop = 0;
            userResponse = '';
            currentTypingElement = null;
        }
        
        function setupLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    changeLanguage(this.dataset.lang);
                });
            });
        }
        
        function setupTextareaAutoResize() {
            const textarea = document.getElementById('userTextarea');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 96) + 'px';
            });
        }
        
        function setupInputEvents() {
            const userTextarea = document.getElementById('userTextarea');
            
            userTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const inputValue = this.value.trim();
                    
                    if (inputValue) {
                        processUserInput(inputValue);
                    }
                }
            });
            
            document.getElementById('continueBtn').addEventListener('click', function() {
                const nextMessage = currentLanguage === 'ko' ? 
                    'Portal 19가 곧 준비됩니다!' :
                    currentLanguage === 'en' ? 
                    'Portal 19 will be ready soon!' :
                    'Portal 19 estará pronto em breve!';
                alert(nextMessage);
            });
            
            document.getElementById('restartBtn').addEventListener('click', function() {
                const confirmMessage = currentLanguage === 'ko' ? 
                    'Portal 18을 다시 시작하시겠습니까?' :
                    currentLanguage === 'en' ? 
                    'Do you want to restart Portal 18?' :
                    'Deseja reiniciar o Portal 18?';
                
                if (confirm(confirmMessage)) {
                    resetJourney();
                    setTimeout(() => {
                        startPortalSequence();
                    }, 1000);
                }
            });
        }
        
        async function processUserInput(inputText) {
            userResponse = inputText;
            
            if (firebaseInitialized && db) {
                try {
                    await db.collection("temarix_v3_respostas").add({
                        uid: memoryStorage.mockUser.uid,
                        email: memoryStorage.mockUser.email,
                        portal: "v3-18",
                        resposta: inputText,
                        data: firebase.firestore.Timestamp.now(),
                        idioma: currentLanguage
                    });
                    console.log('Response saved to Firestore');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                }
            } else {
                console.log('Firebase not available, saved locally:', inputText);
                localStorage.setItem('temarix_v3_last_response', JSON.stringify({
                    portal: "v3-18",
                    resposta: inputText,
                    data: new Date().toISOString(),
                    idioma: currentLanguage
                }));
            }
            
            disableUserInput();
            showUserResponse(inputText);
            
            setTimeout(() => {
                showUserReactions(inputText);
            }, 1000);
        }
        
        function disableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = true;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].waitingMessage;
        }
        
        function enableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            setTimeout(() => {
                userTextarea.focus();
            }, 100);
        }
        
        function showUserResponse(text) {
            const inputSection = document.getElementById('userInputSection');
            const userDiv = document.createElement('div');
            userDiv.className = 'user-response';
            const youLabel = translations[currentLanguage].youLabel;
            userDiv.innerHTML = '<strong>' + youLabel + ':</strong> "' + text + '"';
            inputSection.appendChild(userDiv);
            inputSection.classList.add('show');
            
            setTimeout(() => {
                scrollToElement(inputSection);
            }, 100);
        }
        
        async function showUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            reactionsSection.classList.add('show');
            
            for (let i = 0; i < responseCharacters.length; i++) {
                const char = responseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < responseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showFinalSection();
            }, 2000);
        }
        
        async function showFinalSection() {
            const finalSection = document.getElementById('finalSection');
            const finalMessage = document.getElementById('finalMessage');
            
            finalSection.classList.add('show');
            
            const messageText = translations[currentLanguage].finalMessage;
            await typewriterEffect(finalMessage, messageText, 50);
            
            setTimeout(() => {
                scrollToElement(finalSection);
            }, 500);
        }
        
        function initializeTemarix() {
            console.log('Temarix V3 Portal 18 initialized');
            
            setupLanguageButtons();
            setupTextareaAutoResize();
            setupInputEvents();
            
            journeyStarted = true;
            
            setTimeout(() => {
                startPortalSequence();
            }, 1000);
        }
        
        function startPortalSequence() {
            setTimeout(() => {
                showIntro();
            }, 1000);
        }
        
        async function showIntro() {
            const introSection = document.getElementById('portalIntroSection');
            const introElement = document.getElementById('portalIntro');
            
            introSection.classList.add('show');
            
            await typewriterEffect(introElement, translations[currentLanguage].portalIntro, 60);
            
            setTimeout(() => {
                showCharacterResponses();
            }, 2000);
        }
        
        async function showCharacterResponses() {
            const responseSection = document.getElementById('characterResponsesSection');
            responseSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                responseSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showLightMessage();
            }, 2000);
        }
        
        async function showLightMessage() {
            const lightSection = document.getElementById('lightMessageSection');
            const lightMessageEl = document.getElementById('lightMessage');
            
            lightSection.classList.add('show');
            
            await typewriterEffect(lightMessageEl, translations[currentLanguage].lightMessage, 60);
            
            setTimeout(() => {
                showQuestion();
            }, 2000);
        }
        
        async function showQuestion() {
            const questionSection = document.getElementById('portalQuestionSection');
            const questionEl = document.getElementById('portalQuestion');
            
            questionSection.classList.add('show');
            
            await typewriterEffect(questionEl, translations[currentLanguage].portalQuestion, 50);
            
            setTimeout(() => {
                enableUserInput();
            }, 1500);
        }
        
        function getLanguageFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');
            return lang && translations[lang] ? lang : 'en';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Temarix V3 Portal 18 DOM loaded');
            
            initializeFirebase();
            
            currentLanguage = getLanguageFromURL();
            
            currentUser = { 
                uid: 'user-auto-' + Date.now(),
                email: 'auto@temarix.com'
            };
            
            memoryStorage.mockUser = currentUser;
            
            updateStaticTranslations(currentLanguage);
            updateLanguageButtons(currentLanguage);
            initializeTemarix();
        });
    </script>
</body>
</html>