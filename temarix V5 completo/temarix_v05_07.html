<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temarix V5 - Portal 07: The Day I Named My Tears</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            background: #000;
            border-bottom: 1px solid #333;
            position: relative;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo-title {
            font-size: 26px;
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        .logo-subtitle {
            font-size: 15px;
            color: #ccc;
            letter-spacing: 1.5px;
        }
        
        .portal-header-title {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .portal-main-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }
        
        .portal-subtitle {
            font-size: 18px;
            color: #ff9999;
            letter-spacing: 1.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        .language-buttons {
            display: flex;
            gap: 10px;
        }
        
        .lang-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 18px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lang-btn:hover {
            background: #666;
        }
        
        .lang-btn.active {
            background: #ff6b6b;
            color: #fff;
        }
        
        .main-content {
            flex: 1;
            max-height: calc(100vh - 80px - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 30px 20px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .portal-container {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 200vh;
        }
        
        .portal-intro-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 200px;
        }
        
        .portal-intro {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.8;
            white-space: pre-wrap;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
        }
        
        .character-responses-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 800px;
        }
        
        .character-response {
            color: #fff;
            font-size: 18px;
            margin: 40px 0;
            text-align: left;
            opacity: 0;
            white-space: pre-wrap;
            transition: opacity 0.8s ease-in;
            background: none;
            border: none;
            padding: 0;
            min-height: 80px;
        }
        
        .character-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .character-dialogue {
            color: #fff;
            line-height: 1.7;
            font-size: 17px;
            white-space: pre-wrap;
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: #ff6b6b;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .follow-up-section {
            margin: 50px 0;
            opacity: 0;
            min-height: 150px;
        }
        
        .follow-up-question {
            font-size: 22px;
            color: #fff;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.6;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .user-input-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 100px;
        }
        
        .user-response {
            color: #fff;
            margin: 30px 0;
            text-align: left;
            font-size: 18px;
            background: none;
            border: none;
            padding: 0;
            white-space: pre-wrap;
        }
        
        .user-response strong {
            color: #ff6b6b;
            margin-right: 8px;
        }
        
        .user-reactions-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 400px;
        }
        
        .light-message-section {
            margin: 50px 0;
            opacity: 0;
            background: none;
            border: none;
            padding: 0;
            min-height: 100px;
        }
        
        .light-message {
            font-size: 20px;
            color: #ff6b6b;
            line-height: 1.8;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-section {
            margin: 60px 0;
            opacity: 0;
            text-align: center;
            background: none;
            border: none;
            padding: 40px 20px;
            min-height: 300px;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.05);
        }
        
        .navigation-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 30px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .navigation-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
            line-height: 1.8;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            border: 2px solid transparent;
        }
        
        .nav-btn:hover {
            background: #666;
            border-color: #ff6b6b;
        }
        
        .nav-btn.primary {
            background: #ff6b6b;
            color: #fff;
            font-weight: bold;
        }
        
        .nav-btn.primary:hover {
            background: #ff8888;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .input-fixed-bottom {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000;
            border-top: 1px solid #333;
            padding: 25px;
            z-index: 100;
            flex-shrink: 0;
            height: 120px;
        }
        
        .input-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .input-prefix {
            color: #ff6b6b;
            font-size: 20px;
            margin-top: 8px;
            flex-shrink: 0;
        }
        
        .user-textarea {
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            width: 100%;
            padding: 12px 8px;
            outline: none;
            resize: none;
            min-height: 32px;
            max-height: 96px;
            line-height: 1.6;
            transition: border-color 0.3s ease;
            overflow-y: auto;
        }
        
        .user-textarea:focus {
            border-bottom-color: #ff6b6b;
        }
        
        .user-textarea::placeholder {
            color: #666;
        }
        
        .user-textarea:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.2);
        }
        
        .main-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .main-content::-webkit-scrollbar-track {
            background: #111;
            border-radius: 6px;
        }
        
        .main-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #111;
        }
        
        .main-content::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .show {
            opacity: 1 !important;
            transition: opacity 1s ease-in;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-bar {
                padding: 20px 15px;
                height: 70px;
                flex-direction: column;
                gap: 10px;
            }
            
            .main-content {
                max-height: calc(100vh - 70px - 120px);
                padding: 20px 15px;
            }
            
            .logo-title {
                font-size: 22px;
            }
            
            .portal-main-title {
                font-size: 22px;
            }
            
            .portal-subtitle {
                font-size: 16px;
            }
            
            .lang-btn {
                font-size: 12px;
                padding: 8px 14px;
            }
            
            .portal-intro {
                font-size: 18px;
            }
            
            .follow-up-question {
                font-size: 20px;
            }
            
            .character-response {
                font-size: 16px;
            }
            
            .input-fixed-bottom {
                padding: 20px;
            }
            
            .navigation-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
            }
            
            .navigation-title {
                font-size: 24px;
            }
            
            .navigation-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="logo-section">
            <div class="logo-title">TEMARIX V5</div>
            <div class="logo-subtitle" id="logoSubtitle">Emotional Alchemy</div>
        </div>
        
        <div class="portal-header-title">
            <div class="portal-main-title" id="portalMainTitle">Portal 07: The Day I Named My Tears</div>
            <div class="portal-subtitle" id="portalSubtitle">Giving meaning to what falls from within</div>
        </div>
        
        <div class="header-right">
            <div class="language-buttons">
                <button class="lang-btn" data-lang="ko">KR</button>
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="portal-container">
            <div class="portal-intro-section" id="portalIntroSection">
                <div class="portal-intro" id="portalIntro"></div>
            </div>

            <div class="character-responses-section" id="characterResponsesSection">
            </div>

            <div class="follow-up-section" id="followUpSection">
                <div class="follow-up-question" id="followUpQuestion"></div>
            </div>

            <div class="user-input-section" id="userInputSection">
            </div>
            
            <div class="user-reactions-section" id="userReactionsSection">
            </div>

            <div class="light-message-section" id="lightMessageSection">
                <div class="character-name" id="lightTitle">✨ Word of Light</div>
                <div class="light-message" id="lightMessage"></div>
            </div>
            
            <div class="navigation-section" id="navigationSection">
                <div class="navigation-title" id="navigationTitle">💧 Portal 07 Complete</div>
                <div class="navigation-message" id="navigationMessage"></div>
                <div class="navigation-buttons">
                    <button class="nav-btn primary" id="nextPortalBtn">Continue to Portal 08</button>
                    <button class="nav-btn" id="stayPortalBtn">Stay with these tears</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="input-fixed-bottom">
        <div class="input-container">
            <div class="input-prefix">></div>
            <textarea class="user-textarea" 
                      id="userTextarea" 
                      placeholder="Tell me about an unforgettable tear from your life... (Press Enter to send)"
                      rows="1"
                      maxlength="800"></textarea>
        </div>
    </div>

    <script>
        // Global state management
        let state = {
            db: null,
            auth: null,
            firebaseInitialized: false,
            currentUser: null,
            currentLanguage: 'en',
            userResponse: '',
            journeyStarted: false,
            currentTypingElement: null,
            typingIntervals: [],
            awaitingSecondResponse: false,
            userResponses: []
        };
        
        // Portal navigation configuration
        const portalConfig = {
            currentPortal: "v5-07",
            nextPortal: "v5-08",
            nextPortalFile: "temarix_v05_08.html"
        };
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBjsINSqPUGdpRPRMYiVg6SkVJJOk9YGsY",
            authDomain: "canal-vivo-chat.firebaseapp.com",
            projectId: "canal-vivo-chat",
            storageBucket: "canal-vivo-chat.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdefghijklmnopqr"
        };
        
        // Initialize Firebase with error handling
        function initializeFirebase() {
            return new Promise((resolve) => {
                try {
                    if (typeof firebase !== 'undefined') {
                        firebase.initializeApp(firebaseConfig);
                        state.db = firebase.firestore();
                        state.auth = firebase.auth();
                        state.firebaseInitialized = true;
                        
                        state.auth.onAuthStateChanged((user) => {
                            if (user) {
                                state.currentUser = user;
                            } else {
                                state.currentUser = {
                                    uid: 'anonymous-' + Date.now(),
                                    email: 'anonymous@temarix.com',
                                    isAnonymous: true
                                };
                            }
                            showConnectionStatus(true);
                        });
                        
                        console.log('Firebase initialized successfully');
                    } else {
                        console.log('Firebase SDK not loaded');
                        state.currentUser = {
                            uid: 'anonymous-' + Date.now(),
                            email: 'anonymous@temarix.com',
                            isAnonymous: true
                        };
                        showConnectionStatus(false);
                    }
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    state.currentUser = {
                        uid: 'anonymous-' + Date.now(),
                        email: 'anonymous@temarix.com',
                        isAnonymous: true
                    };
                    showConnectionStatus(false);
                }
                resolve();
            });
        }
        
        // Show connection status to user
        function showConnectionStatus(isOnline) {
            const existingStatus = document.querySelector('.connection-status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            if (!isOnline) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'connection-status';
                statusDiv.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: rgba(255, 107, 107, 0.9);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                    opacity: 0.8;
                `;
                statusDiv.textContent = state.currentLanguage === 'ko' ? '오프라인 모드' : 
                                       state.currentLanguage === 'pt' ? 'Modo offline' : 'Offline mode';
                document.body.appendChild(statusDiv);
                
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.remove();
                    }
                }, 5000);
            }
        }

        // Translations object
        const translations = {
            ko: {
                title: "Temarix V5 - Portal 07: 눈물에게 이름을 준 날",
                logoSubtitle: "감정 연금술",
                portalMainTitle: "Portal 07: 눈물에게 이름을 준 날",
                portalSubtitle: "내면에서 흘러나온 것들에 의미를 부여하기",
                portalIntro: "💧 \"당신의 삶에서, 잊히지 않는 한 방울의 눈물이 있다면...\n그건 언제였나요?\"\n\n\"그 눈물은 어떤 감정의 이름을 가지고 있었나요?\"",
                emotionalBridge: "눈물은 말이 없지만, 감정의 진실을 가장 먼저 말합니다.\n지금, 그 눈물에게 이름을 줄 수 있나요?",
                followUpQuestion: "그 눈물을 다시 떠올리며,\n지금 그 감정에게 한마디를 건넨다면 뭐라고 하고 싶나요?",
                lightTitle: "✨ 빛의 한마디",
                lightMessage: "눈물은 사라지지 않아요.\n감정의 물감이 되어, 오늘 당신을 더 선명하게 만들죠.",
                navigationTitle: "💧 Portal 07 완료",
                navigationMessage: "당신은 눈물에게 이름을 주었습니다.\n\n그 눈물이 부끄러운 흔적이 아니라, 살아있었다는 증거가 되었습니다.\n이제 당신은 울었던 나를 사랑할 수 있는 사람이 되었습니다.\n\n눈물은 감정의 언어였고, 당신은 그 언어를 이해하는 사람입니다.",
                nextPortalBtn: "Portal 08로 이어가기",
                stayPortalBtn: "이 눈물과 머물기",
                inputPlaceholder: "당신의 삶에서 잊을 수 없는 눈물에 대해 말해주세요... (Enter로 전송)",
                youLabel: "당신",
                waitingMessage: "응답을 기다리는 중...",
                confirmNextPortal: "Portal 08: 무너졌던 나를 끌어안는 밤으로 이동하시겠습니까?",
                confirmStay: "이 눈물과 더 머물며 감정을 깊이 느끼시겠습니까?",
                transitionMessage: "새로운 여정이 시작됩니다..."
            },
            en: {
                title: "Temarix V5 - Portal 07: The Day I Named My Tears",
                logoSubtitle: "Emotional Alchemy",
                portalMainTitle: "Portal 07: The Day I Named My Tears",
                portalSubtitle: "Giving meaning to what falls from within",
                portalIntro: "💧 \"In your life, if there was an unforgettable tear...\nwhen was that?\"\n\n\"What emotion's name did that tear carry?\"",
                emotionalBridge: "Tears speak no words, but they are the first to tell the truth of emotions.\nNow, can you give that tear a name?",
                followUpQuestion: "Recalling that tear again,\nwhat would you like to say to that emotion now?",
                lightTitle: "✨ Word of Light",
                lightMessage: "Tears don't disappear.\nThey become the paint of emotions, making you more vivid today.",
                navigationTitle: "💧 Portal 07 Complete",
                navigationMessage: "You have given your tears a name.\n\nThose tears are no longer shameful traces, but evidence of having lived.\nNow you have become someone who can love the self that cried.\n\nTears were the language of emotions, and you are someone who understands that language.",
                nextPortalBtn: "Continue to Portal 08",
                stayPortalBtn: "Stay with these tears",
                inputPlaceholder: "Tell me about an unforgettable tear from your life... (Press Enter to send)",
                youLabel: "You",
                waitingMessage: "Waiting for response...",
                confirmNextPortal: "Do you want to continue to Portal 08: The Night I Embraced My Broken Self?",
                confirmStay: "Do you want to stay longer with these tears to deeply feel the emotions?",
                transitionMessage: "A new journey begins..."
            },
            pt: {
                title: "Temarix V5 - Portal 07: O Dia em que Dei Nome às Minhas Lágrimas",
                logoSubtitle: "Alquimia Emocional",
                portalMainTitle: "Portal 07: O Dia em que Dei Nome às Minhas Lágrimas",
                portalSubtitle: "Dando significado ao que cai de dentro",
                portalIntro: "💧 \"Em sua vida, se houve uma lágrima inesquecível...\nquando foi isso?\"\n\n\"Que nome de emoção essa lágrima carregava?\"",
                emotionalBridge: "As lágrimas não falam palavras, mas são as primeiras a dizer a verdade das emoções.\nAgora, você pode dar um nome a essa lágrima?",
                followUpQuestion: "Lembrando dessa lágrima novamente,\no que gostaria de dizer para essa emoção agora?",
                lightTitle: "✨ Palavra de Luz",
                lightMessage: "As lágrimas não desaparecem.\nElas se tornam a tinta das emoções, tornando você mais vívido hoje.",
                navigationTitle: "💧 Portal 07 Completo",
                navigationMessage: "Você deu um nome às suas lágrimas.\n\nEssas lágrimas não são mais rastros vergonhosos, mas evidência de ter vivido.\nAgora você se tornou alguém que pode amar o eu que chorou.\n\nAs lágrimas eram a linguagem das emoções, e você é alguém que entende essa linguagem.",
                nextPortalBtn: "Continuar para Portal 08",
                stayPortalBtn: "Ficar com estas lágrimas",
                inputPlaceholder: "Conte-me sobre uma lágrima inesquecível de sua vida... (Enter para enviar)",
                youLabel: "Você",
                waitingMessage: "Aguardando resposta...",
                confirmNextPortal: "Deseja continuar para Portal 08: A Noite em que Abracei Meu Eu Quebrado?",
                confirmStay: "Deseja ficar mais tempo com estas lágrimas para sentir profundamente as emoções?",
                transitionMessage: "Uma nova jornada começa..."
            }
        };
        
        // Character definitions
        const characters = [
            { name: "Noah", emoji: "🧑‍🦱", text: {
                ko: "그 눈물은 누구도 알아주지 않았지만,\n지금의 너는 그걸 기억해주고 있어.",
                en: "That tear went unnoticed by everyone,\nbut the you of now remembers it.",
                pt: "Essa lágrima passou despercebida por todos,\nmas o você de agora a lembra."
            }},
            { name: "Ely", emoji: "🧝‍♀️", text: {
                ko: "눈물은 말이 없지만,\n감정의 진실을 가장 먼저 말하죠.",
                en: "Tears speak no words,\nbut they are first to tell the truth of emotions.",
                pt: "As lágrimas não falam,\nmas são as primeiras a dizer a verdade das emoções."
            }},
            { name: "Sora", emoji: "🧕", text: {
                ko: "당신이 울었던 그날,\n사실은 가장 솔직했던 날이기도 해요.",
                en: "The day you cried\nwas actually the day you were most honest.",
                pt: "O dia em que você chorou\nfoi na verdade o dia em que foi mais honesto."
            }},
            { name: "Kael", emoji: "🧙", text: {
                ko: "이제 그 눈물에게 이름을 주었으니,\n그건 잊힌 감정이 아니라, 기억된 감정이야.",
                en: "Now that you've given that tear a name,\nit's not a forgotten emotion, but a remembered one.",
                pt: "Agora que você deu um nome a essa lágrima,\nnão é uma emoção esquecida, mas lembrada."
            }},
            { name: "Mira", emoji: "🧑‍🎨", text: {
                ko: "그 눈물은 흐르는 물감 같았어요.\n감정의 풍경을 처음 그린 날이었겠죠.",
                en: "That tear was like flowing paint.\nIt was the day you first painted an emotional landscape.",
                pt: "Essa lágrima era como tinta fluindo.\nFoi o dia em que você pintou pela primeira vez uma paisagem emocional."
            }},
            { name: "Cris", emoji: "🦸‍♂️", text: {
                ko: "울음을 약함이라 말한 사람은\n진짜 아픔을 겪어본 적 없는 사람이야.",
                en: "Those who call crying weakness\nhave never experienced real pain.",
                pt: "Aqueles que chamam o choro de fraqueza\nnunca experimentaram dor real."
            }},
            { name: "Enya", emoji: "🧑‍🚀", text: {
                ko: "눈물은 감정이 몸을 통해 나온 흔적.\n당신의 눈물은, 존재의 증명이었어요.",
                en: "Tears are traces of emotions flowing through the body.\nYour tears were proof of existence.",
                pt: "As lágrimas são rastros de emoções fluindo pelo corpo.\nSuas lágrimas foram prova de existência."
            }},
            { name: "Lian", emoji: "🧘", text: {
                ko: "당신이 울었던 날,\n사실은 진짜 자신에게 처음 말을 건 날이에요.",
                en: "The day you cried\nwas actually the day you first spoke to your true self.",
                pt: "O dia em que você chorou\nfoi na verdade o dia em que falou pela primeira vez com seu verdadeiro eu."
            }}
        ];

        // Tear analysis function
        function analyzeTearType(userInput) {
            const input = userInput.toLowerCase();
            
            const tearKeywords = {
                loneliness: ['alone', 'lonely', 'nobody', 'isolated', '혼자', '외로', '아무도', 'sozinho', 'solitário', 'ninguém'],
                loss: ['died', 'death', 'lost', 'goodbye', 'funeral', '죽었', '잃었', '이별', 'morreu', 'morte', 'perdeu', 'despedida'],
                graduation: ['graduation', 'school', 'leaving', 'goodbye', '졸업', '학교', '떠나', 'formatura', 'escola', 'partida'],
                failure: ['failed', 'failure', 'disappointed', 'rejected', '실패', '떨어졌', '거절', 'falhou', 'fracasso', 'rejeitado'],
                happiness: ['happy', 'joy', 'proud', 'achievement', '기뻐서', '행복해서', '자랑', 'feliz', 'alegria', 'orgulho'],
                relief: ['relief', 'finally', 'over', 'ended', '안도', '드디어', '끝났', 'alívio', 'finalmente', 'terminou'],
                overwhelm: ['overwhelmed', 'too much', 'pressure', 'stressed', '벅차', '압도', '스트레스', 'sobrecarregado', 'pressão'],
                love: ['love', 'wedding', 'birth', 'family', '사랑', '결혼', '출생', 'amor', 'casamento', 'nascimento'],
                regret: ['regret', 'sorry', 'should have', 'mistake', '후회', '미안', '실수', 'arrependimento', 'deveria'],
                fear: ['scared', 'afraid', 'terrified', 'panic', '무서워', '두려워', '공포', 'medo', 'assustado', 'pânico']
            };
            
            let detectedTypes = [];
            for (const [type, keywords] of Object.entries(tearKeywords)) {
                for (const keyword of keywords) {
                    if (input.includes(keyword)) {
                        detectedTypes.push(type);
                        break;
                    }
                }
            }
            
            if (detectedTypes.length === 0) {
                detectedTypes = ['general'];
            }
            
            return detectedTypes[0];
        }
        
        // Response characters with tear-based responses
        const responseCharacters = [
            {
                name: "Sora", emoji: "🧕",
                getResponse: (userInput, lang) => {
                    const tearType = analyzeTearType(userInput);
                    
                    const responses = {
                        ko: {
                            loneliness: "외로움의 눈물은 가장 진실한 눈물이에요.\n그 눈물이 당신을 더 깊은 사람으로 만들었어요.",
                            loss: "상실의 눈물은 사랑의 또 다른 이름이에요.\n그 눈물 속에는 소중했던 기억이 살아 있어요.",
                            graduation: "이별의 눈물은 성장의 눈물이기도 해요.\n당신은 그 눈물로 새로운 시작을 받아들였어요.",
                            failure: "실패의 눈물은 용기의 증거예요.\n시도했기 때문에 울 수 있었던 거니까요.",
                            happiness: "기쁨의 눈물은 가장 순수한 눈물이에요.\n그 순간을 온전히 느낀 당신이 아름다워요.",
                            relief: "안도의 눈물은 해방의 눈물이에요.\n당신은 긴 터널을 통과했어요.",
                            overwhelm: "벅찬 눈물은 당신이 얼마나 열심히 살았는지 보여줘요.\n그 눈물은 노력의 결정이에요.",
                            love: "사랑의 눈물은 마음이 넘쳐흘러서 생긴 거예요.\n그 풍성함이 당신을 더 따뜻하게 만들었어요.",
                            regret: "후회의 눈물은 당신이 더 나은 사람이 되고 싶다는 마음이에요.\n그 눈물이 당신을 성장시켰어요.",
                            fear: "두려움의 눈물도 용기의 시작이에요.\n무서워하면서도 앞으로 나아간 당신이 대단해요.",
                            general: "이제 그 눈물은 부끄러운 흔적이 아니라,\n살아있었다는 증거가 되었어요."
                        },
                        en: {
                            loneliness: "Tears of loneliness are the most truthful tears.\nThose tears made you a deeper person.",
                            loss: "Tears of loss are another name for love.\nPrecious memories live within those tears.",
                            graduation: "Tears of farewell are also tears of growth.\nYou accepted new beginnings with those tears.",
                            failure: "Tears of failure are proof of courage.\nYou could cry because you tried.",
                            happiness: "Tears of joy are the purest tears.\nYou are beautiful for feeling that moment completely.",
                            relief: "Tears of relief are tears of liberation.\nYou passed through a long tunnel.",
                            overwhelm: "Overwhelming tears show how hard you've lived.\nThose tears are crystals of effort.",
                            love: "Tears of love came from an overflowing heart.\nThat abundance made you warmer.",
                            regret: "Tears of regret are your desire to become a better person.\nThose tears helped you grow.",
                            fear: "Tears of fear are also the beginning of courage.\nYou're amazing for moving forward despite being scared.",
                            general: "Now those tears are no longer shameful traces,\nbut evidence of having lived."
                        },
                        pt: {
                            loneliness: "Lágrimas de solidão são as lágrimas mais verdadeiras.\nEssas lágrimas te tornaram uma pessoa mais profunda.",
                            loss: "Lágrimas de perda são outro nome para amor.\nMemórias preciosas vivem dentro dessas lágrimas.",
                            graduation: "Lágrimas de despedida são também lágrimas de crescimento.\nVocê aceitou novos começos com essas lágrimas.",
                            failure: "Lágrimas de fracasso são prova de coragem.\nVocê pôde chorar porque tentou.",
                            happiness: "Lágrimas de alegria são as lágrimas mais puras.\nVocê é belo por sentir aquele momento completamente.",
                            relief: "Lágrimas de alívio são lágrimas de libertação.\nVocê passou por um longo túnel.",
                            overwhelm: "Lágrimas avassaladoras mostram o quão intensamente você viveu.\nEssas lágrimas são cristais de esforço.",
                            love: "Lágrimas de amor vieram de um coração transbordante.\nEssa abundância te tornou mais caloroso.",
                            regret: "Lágrimas de arrependimento são seu desejo de se tornar uma pessoa melhor.\nEssas lágrimas te ajudaram a crescer.",
                            fear: "Lágrimas de medo são também o início da coragem.\nVocê é incrível por seguir em frente apesar do medo.",
                            general: "Agora essas lágrimas não são mais rastros vergonhosos,\nmas evidência de ter vivido."
                        }
                    };
                    
                    return responses[lang][tearType] || responses[lang]['general'];
                }
            },
            {
                name: "Lian", emoji: "🧘",
                getResponse: (userInput, lang) => {
                    const tearType = analyzeTearType(userInput);
                    
                    const responses = {
                        ko: {
                            loneliness: "외로웠던 당신의 그 시간이 지금의 공감 능력을 만들었어요.\n그 눈물은 치유의 씨앗이었어요.",
                            loss: "상실의 아픔이 지금 당신의 마음을 더 넓게 만들었어요.\n그 눈물은 사랑을 더 깊이 이해하게 했어요.",
                            graduation: "그날의 눈물은 시간을 통과한 회복이에요.\n과거와 현재가 연결된 순간이었어요.",
                            failure: "실패의 순간에도 울 수 있었던 건 아직 희망이 있었기 때문이에요.\n그 눈물이 재시작의 힘이 되었어요.",
                            happiness: "기쁨의 눈물은 당신이 감정을 온전히 받아들였다는 증거예요.\n그런 당신이 아름다워요.",
                            relief: "안도의 눈물 속에는 견뎌낸 시간의 무게가 담겨 있어요.\n그 견딤이 지금의 당신을 만들었어요.",
                            overwhelm: "벅찼던 마음이 눈물로 흘러나온 순간,\n당신은 자신의 한계를 인정하고 받아들였어요.",
                            love: "사랑의 눈물은 마음의 확장이에요.\n그 순간 당신의 마음은 우주가 되었어요.",
                            regret: "후회의 눈물은 성찰의 시작이에요.\n그 눈물이 당신을 더 지혜로운 사람으로 만들었어요.",
                            fear: "두려움의 눈물도 용기의 일부예요.\n무서워하면서도 느꼈던 그 감정이 당신을 성장시켰어요.",
                            general: "그날의 감정이 지금 당신과 연결되었어요.\n그건 시간을 통과한 회복이에요."
                        },
                        en: {
                            loneliness: "Your lonely times created your current ability to empathize.\nThose tears were seeds of healing.",
                            loss: "The pain of loss has made your heart wider now.\nThose tears helped you understand love more deeply.",
                            graduation: "The tears of that day are recovery that passed through time.\nIt was a moment when past and present connected.",
                            failure: "Being able to cry even in moments of failure meant you still had hope.\nThose tears became the strength to restart.",
                            happiness: "Tears of joy are proof that you fully accepted emotions.\nSuch a you is beautiful.",
                            relief: "Tears of relief contain the weight of time endured.\nThat endurance created the you of today.",
                            overwhelm: "The moment your overwhelmed heart flowed out as tears,\nyou acknowledged and accepted your limits.",
                            love: "Tears of love are the expansion of the heart.\nIn that moment your heart became the universe.",
                            regret: "Tears of regret are the beginning of reflection.\nThose tears made you a wiser person.",
                            fear: "Tears of fear are also part of courage.\nThe emotions you felt while being scared helped you grow.",
                            general: "The emotions of that day connected with you now.\nThat's recovery that passed through time."
                        },
                        pt: {
                            loneliness: "Seus tempos solitários criaram sua atual capacidade de empatia.\nEssas lágrimas foram sementes de cura.",
                            loss: "A dor da perda tornou seu coração mais amplo agora.\nEssas lágrimas te ajudaram a entender o amor mais profundamente.",
                            graduation: "As lágrimas daquele dia são recuperação que passou pelo tempo.\nFoi um momento quando passado e presente se conectaram.",
                            failure: "Poder chorar mesmo em momentos de fracasso significava que ainda havia esperança.\nEssas lágrimas se tornaram força para recomeçar.",
                            happiness: "Lágrimas de alegria são prova de que você aceitou completamente as emoções.\nTal você é belo.",
                            relief: "Lágrimas de alívio contêm o peso do tempo resistido.\nEssa resistência criou o você de hoje.",
                            overwhelm: "O momento em que seu coração sobrecarregado fluiu como lágrimas,\nvocê reconheceu e aceitou seus limites.",
                            love: "Lágrimas de amor são a expansão do coração.\nNaquele momento seu coração se tornou o universo.",
                            regret: "Lágrimas de arrependimento são o início da reflexão.\nEssas lágrimas te tornaram uma pessoa mais sábia.",
                            fear: "Lágrimas de medo também são parte da coragem.\nAs emoções que você sentiu enquanto tinha medo te ajudaram a crescer.",
                            general: "As emoções daquele dia se conectaram com você agora.\nIssa é recuperação que passou pelo tempo."
                        }
                    };
                    
                    return responses[lang][tearType] || responses[lang]['general'];
                }
            },
            {
                name: "Mira", emoji: "🧑‍🎨",
                getResponse: (userInput, lang) => {
                    const tearType = analyzeTearType(userInput);
                    
                    const responses = {
                        ko: {
                            loneliness: "외로움의 눈물은 깊은 푸른색이었을 거예요.\n그 색이 지금 당신의 깊이를 만들었어요.",
                            loss: "상실의 눈물은 회색과 흰색이 섞인 색이었겠죠.\n그 색에서 새로운 희망의 색이 나올 거예요.",
                            graduation: "이별의 눈물은 주황빛이었을 거예요.\n끝과 시작이 만나는 색이니까요.",
                            failure: "실패의 눈물은 진한 남색이었지만,\n그 속에는 다시 일어설 빨간색이 숨어 있었어요.",
                            happiness: "기쁨의 눈물은 투명한 금색이었을 거예요.\n가장 순수하고 아름다운 색이죠.",
                            relief: "안도의 눈물은 연한 초록색이었을 거예요.\n평화와 휴식의 색이니까요.",
                            overwhelm: "벅찬 눈물은 무지개색이었을 거예요.\n모든 감정이 한 번에 흘러나온 거니까요.",
                            love: "사랑의 눈물은 따뜻한 분홍색이었을 거예요.\n마음이 가득 차서 넘쳐흐른 색이죠.",
                            regret: "후회의 눈물은 보라색이었지만,\n그 속에는 배움의 노란색이 섞여 있었어요.",
                            fear: "두려움의 눈물은 어두운 색이었지만,\n그 안에서 용기의 빛이 태어났어요.",
                            general: "눈물은 사라지지 않아요.\n감정의 물감이 되어, 오늘 당신을 더 선명하게 만들죠."
                        },
                        en: {
                            loneliness: "Tears of loneliness would have been deep blue.\nThat color created your current depth.",
                            loss: "Tears of loss would have been a mix of gray and white.\nNew colors of hope will emerge from that color.",
                            graduation: "Tears of farewell would have been orange.\nBecause it's the color where endings and beginnings meet.",
                            failure: "Tears of failure were dark navy,\nbut red for rising again was hidden within.",
                            happiness: "Tears of joy would have been transparent gold.\nThe most pure and beautiful color.",
                            relief: "Tears of relief would have been light green.\nBecause it's the color of peace and rest.",
                            overwhelm: "Overwhelming tears would have been rainbow-colored.\nBecause all emotions flowed out at once.",
                            love: "Tears of love would have been warm pink.\nThe color of a heart overflowing from being full.",
                            regret: "Tears of regret were purple,\nbut yellow of learning was mixed within.",
                            fear: "Tears of fear were dark colors,\nbut the light of courage was born from within.",
                            general: "Tears don't disappear.\nThey become the paint of emotions, making you more vivid today."
                        },
                        pt: {
                            loneliness: "Lágrimas de solidão teriam sido azul profundo.\nEssa cor criou sua profundidade atual.",
                            loss: "Lágrimas de perda teriam sido uma mistura de cinza e branco.\nNovas cores de esperança emergirão dessa cor.",
                            graduation: "Lágrimas de despedida teriam sido laranja.\nPorque é a cor onde fins e começos se encontram.",
                            failure: "Lágrimas de fracasso eram azul marinho escuro,\nmas vermelho para se levantar novamente estava escondido dentro.",
                            happiness: "Lágrimas de alegria teriam sido ouro transparente.\nA cor mais pura e bela.",
                            relief: "Lágrimas de alívio teriam sido verde claro.\nPorque é a cor da paz e do descanso.",
                            overwhelm: "Lágrimas avassaladoras teriam sido cor do arco-íris.\nPorque todas as emoções fluíram de uma vez.",
                            love: "Lágrimas de amor teriam sido rosa quente.\nA cor de um coração transbordando por estar cheio.",
                            regret: "Lágrimas de arrependimento eram roxas,\nmas amarelo de aprendizado estava misturado dentro.",
                            fear: "Lágrimas de medo eram cores escuras,\nmas a luz da coragem nasceu de dentro.",
                            general: "As lágrimas não desaparecem.\nElas se tornam a tinta das emoções, tornando você mais vívido hoje."
                        }
                    };
                    
                    return responses[lang][tearType] || responses[lang]['general'];
                }
            }
        ];
        
        // Typewriter effect
        function typewriterEffect(element, text, speed = 80) {
            return new Promise((resolve) => {
                if (state.currentTypingElement) {
                    state.currentTypingElement.classList.remove('typing-cursor');
                }
                
                let i = 0;
                element.innerHTML = '';
                element.classList.add('typing-cursor');
                state.currentTypingElement = element;
                
                const typingInterval = setInterval(() => {
                    if (!document.contains(element)) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        state.currentTypingElement = null;
                        resolve();
                        return;
                    }
                    
                    element.innerHTML += text.charAt(i);
                    i++;
                    
                    if (i % 10 === 0) {
                        scrollToFollowTyping(element);
                    }
                    
                    if (i === text.length) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        state.currentTypingElement = null;
                        resolve();
                    }
                }, speed);
                
                state.typingIntervals.push(typingInterval);
            });
        }
        
        // Clear all typing effects
        function clearAllTypingEffects() {
            state.typingIntervals.forEach(interval => clearInterval(interval));
            state.typingIntervals = [];
            
            if (state.currentTypingElement) {
                state.currentTypingElement.classList.remove('typing-cursor');
                state.currentTypingElement = null;
            }
        }
        
        // Scroll functions
        function scrollToFollowTyping(element) {
            const mainContent = document.getElementById('mainContent');
            const elementRect = element.getBoundingClientRect();
            const containerRect = mainContent.getBoundingClientRect();
            
            if (elementRect.bottom > containerRect.bottom - 150) {
                const scrollTop = mainContent.scrollTop;
                const elementOffsetTop = element.offsetTop;
                const targetScroll = elementOffsetTop - (containerRect.height / 2);
                
                mainContent.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }
        
        function scrollToElement(element) {
            const mainContent = document.getElementById('mainContent');
            const elementOffsetTop = element.offsetTop;
            const containerHeight = mainContent.clientHeight;
            const targetScroll = elementOffsetTop - (containerHeight / 3);
            
            mainContent.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }
        
        // Language management
        function updateLanguageButtons(lang) {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateStaticTranslations(lang) {
            const t = translations[lang];
            document.title = t.title;
            document.getElementById('logoSubtitle').textContent = t.logoSubtitle;
            document.getElementById('portalMainTitle').textContent = t.portalMainTitle;
            document.getElementById('portalSubtitle').textContent = t.portalSubtitle;
            document.getElementById('lightTitle').textContent = t.lightTitle;
            document.getElementById('navigationTitle').textContent = t.navigationTitle;
            document.getElementById('nextPortalBtn').textContent = t.nextPortalBtn;
            document.getElementById('stayPortalBtn').textContent = t.stayPortalBtn;
            document.getElementById('userTextarea').placeholder = t.inputPlaceholder;
        }
        
        function changeLanguage(lang) {
            if (!translations[lang] || state.currentLanguage === lang) return;
            
            state.currentLanguage = lang;
            updateLanguageButtons(lang);
            updateStaticTranslations(lang);
            
            if (state.journeyStarted) {
                resetJourney();
                setTimeout(() => {
                    startPortalSequence();
                }, 1000);
            }
        }
        
        // Journey management
        function resetJourney() {
            clearAllTypingEffects();
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            
            const sectionsToReset = [
                'portalIntroSection', 'characterResponsesSection', 
                'followUpSection', 'userInputSection',
                'userReactionsSection', 'lightMessageSection', 'navigationSection'
            ];
            
            sectionsToReset.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('show');
                    section.style.opacity = '0';
                    if (sectionId === 'characterResponsesSection' || 
                        sectionId === 'userInputSection' || 
                        sectionId === 'userReactionsSection') {
                        section.innerHTML = '';
                    }
                }
            });
            
            document.getElementById('portalIntro').innerHTML = '';
            document.getElementById('followUpQuestion').innerHTML = '';
            document.getElementById('lightMessage').innerHTML = '';
            document.getElementById('navigationMessage').innerHTML = '';
            
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[state.currentLanguage].inputPlaceholder;
            
            document.getElementById('mainContent').scrollTop = 0;
            state.userResponse = '';
            state.currentTypingElement = null;
            state.awaitingSecondResponse = false;
        }
        
        // Save response to database or memory
        async function saveResponse(inputText, step) {
            const responseData = {
                portal: portalConfig.currentPortal,
                resposta: inputText,
                step: step,
                data: new Date().toISOString(),
                idioma: state.currentLanguage,
                userId: state.currentUser ? state.currentUser.uid : 'anonymous',
                userEmail: state.currentUser ? state.currentUser.email : 'anonymous@temarix.com'
            };
            
            if (state.firebaseInitialized && state.db) {
                try {
                    await state.db.collection("temarix_v5_respostas").add({
                        ...responseData,
                        timestamp: firebase.firestore.Timestamp.now()
                    });
                    console.log('Response saved to Firestore');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                    state.userResponses.push(responseData);
                    showConnectionStatus(false);
                }
            } else {
                state.userResponses.push(responseData);
                console.log('Response stored in memory:', responseData);
            }
        }
        
        // User input processing
        async function processUserInput(inputText) {
            state.userResponse = inputText;
            
            await saveResponse(inputText, state.awaitingSecondResponse ? "second" : "first");
            
            disableUserInput();
            showUserResponse(inputText);
            
            setTimeout(() => {
                if (!state.awaitingSecondResponse) {
                    showUserReactions(inputText);
                } else {
                    showSecondUserReactions(inputText);
                }
            }, 1000);
        }
        
        function disableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = true;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[state.currentLanguage].waitingMessage;
        }
        
        function enableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.placeholder = translations[state.currentLanguage].inputPlaceholder;
            
            setTimeout(() => {
                userTextarea.focus();
            }, 100);
        }
        
        function showUserResponse(text) {
            const inputSection = document.getElementById('userInputSection');
            const userDiv = document.createElement('div');
            userDiv.className = 'user-response';
            const youLabel = translations[state.currentLanguage].youLabel;
            userDiv.innerHTML = '<strong>' + youLabel + ':</strong> "' + text + '"';
            inputSection.appendChild(userDiv);
            inputSection.classList.add('show');
            
            setTimeout(() => {
                scrollToElement(inputSection);
            }, 100);
        }
        
        // Show character reactions
        async function showUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            reactionsSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[state.currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showFollowUpQuestion();
            }, 2000);
        }
        
        async function showFollowUpQuestion() {
            const followUpSection = document.getElementById('followUpSection');
            const followUpQuestionEl = document.getElementById('followUpQuestion');
            
            followUpSection.classList.add('show');
            
            await typewriterEffect(followUpQuestionEl, translations[state.currentLanguage].followUpQuestion, 50);
            
            setTimeout(() => {
                state.awaitingSecondResponse = true;
                enableUserInput();
            }, 1500);
        }
        
        async function showSecondUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            
            for (let i = 0; i < responseCharacters.length; i++) {
                const char = responseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, state.currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < responseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showLightMessage();
            }, 2000);
        }
        
        async function showLightMessage() {
            const lightSection = document.getElementById('lightMessageSection');
            const lightMessageEl = document.getElementById('lightMessage');
            
            lightSection.classList.add('show');
            
            await typewriterEffect(lightMessageEl, translations[state.currentLanguage].lightMessage, 60);
            
            setTimeout(() => {
                showNavigationSection();
            }, 2000);
        }
        
        async function showNavigationSection() {
            const navigationSection = document.getElementById('navigationSection');
            const navigationMessage = document.getElementById('navigationMessage');
            
            navigationSection.classList.add('show');
            
            const messageText = translations[state.currentLanguage].navigationMessage;
            await typewriterEffect(navigationMessage, messageText, 50);
            
            setTimeout(() => {
                scrollToElement(navigationSection);
            }, 500);
        }
        
        // Portal sequence
        async function startPortalSequence() {
            console.log('Starting portal sequence...');
            setTimeout(() => {
                showIntro();
            }, 1000);
        }
        
        async function showIntro() {
            console.log('Showing intro...');
            const introSection = document.getElementById('portalIntroSection');
            const introElement = document.getElementById('portalIntro');
            
            if (!introSection || !introElement) {
                console.error('Intro elements not found!');
                return;
            }
            
            introSection.classList.add('show');
            
            const introText = translations[state.currentLanguage].portalIntro;
            console.log('Intro text:', introText);
            
            await typewriterEffect(introElement, introText, 60);
            
            setTimeout(async () => {
                await showEmotionalBridge();
            }, 2000);
        }
        
        async function showEmotionalBridge() {
            const introElement = document.getElementById('portalIntro');
            const bridgeText = '\n\n' + translations[state.currentLanguage].emotionalBridge;
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const bridgeP = document.createElement('p');
            bridgeP.style.cssText = `
                margin-top: 30px;
                font-style: italic;
                color: #ff9999;
                font-size: 18px;
                line-height: 1.8;
            `;
            introElement.appendChild(bridgeP);
            
            await typewriterEffect(bridgeP, bridgeText.trim(), 50);
            
            setTimeout(() => {
                showCharacterResponses();
            }, 2000);
        }
        
        async function showCharacterResponses() {
            const responseSection = document.getElementById('characterResponsesSection');
            responseSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                responseSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[state.currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                enableUserInput();
            }, 2000);
        }
        
        // Custom confirm dialog
        function showConfirmDialog(message, callback) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: 'Courier New', monospace;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #222;
                border: 2px solid #ff6b6b;
                padding: 30px;
                max-width: 400px;
                text-align: center;
                color: white;
            `;
            
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.cssText = `
                margin-bottom: 20px;
                line-height: 1.6;
                font-size: 16px;
            `;
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 15px;
                justify-content: center;
            `;
            
            const yesBtn = document.createElement('button');
            const noBtn = document.createElement('button');
            
            const buttonStyle = `
                background: #444;
                color: white;
                border: 1px solid #ff6b6b;
                padding: 10px 20px;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                font-size: 14px;
            `;
            
            yesBtn.style.cssText = buttonStyle + 'background: #ff6b6b;';
            noBtn.style.cssText = buttonStyle;
            
            yesBtn.textContent = state.currentLanguage === 'ko' ? '예' : 
                                state.currentLanguage === 'pt' ? 'Sim' : 'Yes';
            noBtn.textContent = state.currentLanguage === 'ko' ? '아니오' : 
                               state.currentLanguage === 'pt' ? 'Não' : 'No';
            
            yesBtn.onclick = () => {
                document.body.removeChild(overlay);
                callback(true);
            };
            
            noBtn.onclick = () => {
                document.body.removeChild(overlay);
                callback(false);
            };
            
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    callback(false);
                }
            };
            
            buttonContainer.appendChild(yesBtn);
            buttonContainer.appendChild(noBtn);
            modal.appendChild(messageP);
            modal.appendChild(buttonContainer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            yesBtn.focus();
        }
        
        // Event setup
        function setupLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    changeLanguage(this.dataset.lang);
                });
            });
        }
        
        function setupTextareaAutoResize() {
            const textarea = document.getElementById('userTextarea');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 96) + 'px';
            });
        }
        
        function createPortalTransition(callback) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(45deg, #000 0%, #111 50%, #000 100%);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 20000;
                opacity: 0;
                transition: opacity 1s ease-in-out;
                font-family: 'Courier New', monospace;
            `;
            
            const message = document.createElement('div');
            message.style.cssText = `
                color: #ff6b6b;
                font-size: 24px;
                text-align: center;
                margin-bottom: 30px;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.8s ease-out;
            `;
            message.textContent = translations[state.currentLanguage].transitionMessage;
            
            const loader = document.createElement('div');
            loader.style.cssText = `
                width: 60px;
                height: 60px;
                border: 3px solid #333;
                border-top: 3px solid #ff6b6b;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                opacity: 0;
                transition: opacity 0.8s ease-out 0.3s;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
            
            overlay.appendChild(message);
            overlay.appendChild(loader);
            document.body.appendChild(overlay);
            
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 10);
            
            setTimeout(() => {
                message.style.opacity = '1';
                message.style.transform = 'translateY(0)';
                loader.style.opacity = '1';
            }, 300);
            
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    callback();
                }, 1000);
            }, 2500);
        }
        
        function setupInputEvents() {
            const userTextarea = document.getElementById('userTextarea');
            
            userTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const inputValue = this.value.trim();
                    
                    if (inputValue) {
                        processUserInput(inputValue);
                    }
                }
            });
            
            document.getElementById('nextPortalBtn').addEventListener('click', function() {
                const t = translations[state.currentLanguage];
                showConfirmDialog(t.confirmNextPortal, (confirmed) => {
                    if (confirmed) {
                        if (state.firebaseInitialized && state.db) {
                            state.db.collection("temarix_v5_progress").add({
                                userId: state.currentUser.uid,
                                portal: portalConfig.currentPortal,
                                status: "complete",
                                timestamp: firebase.firestore.Timestamp.now()
                            }).catch(error => console.error('Error saving progress:', error));
                        }
                        
                        createPortalTransition(() => {
                            window.location.href = `${portalConfig.nextPortalFile}?lang=${state.currentLanguage}`;
                        });
                    }
                });
            });
            
            document.getElementById('stayPortalBtn').addEventListener('click', function() {
                const t = translations[state.currentLanguage];
                showConfirmDialog(t.confirmStay, (confirmed) => {
                    if (confirmed) {
                        resetJourney();
                        setTimeout(() => {
                            startPortalSequence();
                        }, 1000);
                    }
                });
            });
        }
        
        function getLanguageFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');
            return lang && translations[lang] ? lang : 'en';
        }
        
        function initializeTemarix() {
            console.log('Initializing Temarix V5 Portal 07...');
            console.log('Current state:', state);
            
            setupLanguageButtons();
            setupTextareaAutoResize();
            setupInputEvents();
            
            state.journeyStarted = true;
            console.log('Journey started:', state.journeyStarted);
            
            console.log('Starting portal sequence in 1 second...');
            setTimeout(() => {
                startPortalSequence();
            }, 1000);
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Temarix V5 Portal 07 DOM loaded');
            
            state.currentLanguage = getLanguageFromURL();
            
            updateStaticTranslations(state.currentLanguage);
            updateLanguageButtons(state.currentLanguage);
            
            await initializeFirebase();
            
            initializeTemarix();
        });
    </script>
</body>
</html>