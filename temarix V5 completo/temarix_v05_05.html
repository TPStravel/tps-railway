<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temarix V5 - Portal 05: The Letter I Left for Myself</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            background: #000;
            border-bottom: 1px solid #333;
            position: relative;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo-title {
            font-size: 26px;
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        .logo-subtitle {
            font-size: 15px;
            color: #ccc;
            letter-spacing: 1.5px;
        }
        
        .portal-header-title {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .portal-main-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }
        
        .portal-subtitle {
            font-size: 18px;
            color: #ff9999;
            letter-spacing: 1.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        .language-buttons {
            display: flex;
            gap: 10px;
        }
        
        .lang-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 18px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lang-btn:hover {
            background: #666;
        }
        
        .lang-btn.active {
            background: #ff6b6b;
            color: #fff;
        }
        
        .main-content {
            flex: 1;
            max-height: calc(100vh - 80px - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 30px 20px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .portal-container {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 200vh;
        }
        
        .portal-intro-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 200px;
        }
        
        .portal-intro {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.8;
            white-space: pre-wrap;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
        }
        
        .character-responses-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 800px;
        }
        
        .character-response {
            color: #fff;
            font-size: 18px;
            margin: 40px 0;
            text-align: left;
            opacity: 0;
            white-space: pre-wrap;
            transition: opacity 0.8s ease-in;
            background: none;
            border: none;
            padding: 0;
            min-height: 80px;
        }
        
        .character-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .character-dialogue {
            color: #fff;
            line-height: 1.7;
            font-size: 17px;
            white-space: pre-wrap;
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: #ff6b6b;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .follow-up-section {
            margin: 50px 0;
            opacity: 0;
            min-height: 150px;
        }
        
        .follow-up-question {
            font-size: 22px;
            color: #fff;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.6;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .user-input-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 100px;
        }
        
        .user-response {
            color: #fff;
            margin: 30px 0;
            text-align: left;
            font-size: 18px;
            background: none;
            border: none;
            padding: 0;
            white-space: pre-wrap;
        }
        
        .user-response strong {
            color: #ff6b6b;
            margin-right: 8px;
        }
        
        .user-reactions-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 400px;
        }
        
        .light-message-section {
            margin: 50px 0;
            opacity: 0;
            background: none;
            border: none;
            padding: 0;
            min-height: 100px;
        }
        
        .light-message {
            font-size: 20px;
            color: #ff6b6b;
            line-height: 1.8;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-section {
            margin: 60px 0;
            opacity: 0;
            text-align: center;
            background: none;
            border: none;
            padding: 40px 20px;
            min-height: 300px;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.05);
        }
        
        .navigation-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 30px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .navigation-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
            line-height: 1.8;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            border: 2px solid transparent;
        }
        
        .nav-btn:hover {
            background: #666;
            border-color: #ff6b6b;
        }
        
        .nav-btn.primary {
            background: #ff6b6b;
            color: #fff;
            font-weight: bold;
        }
        
        .nav-btn.primary:hover {
            background: #ff8888;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .input-fixed-bottom {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000;
            border-top: 1px solid #333;
            padding: 25px;
            z-index: 100;
            flex-shrink: 0;
            height: 120px;
        }
        
        .input-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .input-prefix {
            color: #ff6b6b;
            font-size: 20px;
            margin-top: 8px;
            flex-shrink: 0;
        }
        
        .user-textarea {
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            width: 100%;
            padding: 12px 8px;
            outline: none;
            resize: none;
            min-height: 32px;
            max-height: 96px;
            line-height: 1.6;
            transition: border-color 0.3s ease;
            overflow-y: auto;
        }
        
        .user-textarea:focus {
            border-bottom-color: #ff6b6b;
        }
        
        .user-textarea::placeholder {
            color: #666;
        }
        
        .user-textarea:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.2);
        }
        
        .main-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .main-content::-webkit-scrollbar-track {
            background: #111;
            border-radius: 6px;
        }
        
        .main-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #111;
        }
        
        .main-content::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .show {
            opacity: 1 !important;
            transition: opacity 1s ease-in;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-bar {
                padding: 20px 15px;
                height: 70px;
                flex-direction: column;
                gap: 10px;
            }
            
            .main-content {
                max-height: calc(100vh - 70px - 120px);
                padding: 20px 15px;
            }
            
            .logo-title {
                font-size: 22px;
            }
            
            .portal-main-title {
                font-size: 22px;
            }
            
            .portal-subtitle {
                font-size: 16px;
            }
            
            .lang-btn {
                font-size: 12px;
                padding: 8px 14px;
            }
            
            .portal-intro {
                font-size: 18px;
            }
            
            .follow-up-question {
                font-size: 20px;
            }
            
            .character-response {
                font-size: 16px;
            }
            
            .input-fixed-bottom {
                padding: 20px;
            }
            
            .navigation-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
            }
            
            .navigation-title {
                font-size: 24px;
            }
            
            .navigation-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="logo-section">
            <div class="logo-title">TEMARIX V5</div>
            <div class="logo-subtitle" id="logoSubtitle">Emotional Alchemy</div>
        </div>
        
        <div class="portal-header-title">
            <div class="portal-main-title" id="portalMainTitle">Portal 05: The Letter I Left for Myself</div>
            <div class="portal-subtitle" id="portalSubtitle">A message of compassion and recovery</div>
        </div>
        
        <div class="header-right">
            <div class="language-buttons">
                <button class="lang-btn" data-lang="ko">KR</button>
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="portal-container">
            <div class="portal-intro-section" id="portalIntroSection">
                <div class="portal-intro" id="portalIntro"></div>
            </div>

            <div class="character-responses-section" id="characterResponsesSection">
            </div>

            <div class="follow-up-section" id="followUpSection">
                <div class="follow-up-question" id="followUpQuestion"></div>
            </div>

            <div class="user-input-section" id="userInputSection">
            </div>
            
            <div class="user-reactions-section" id="userReactionsSection">
            </div>

            <div class="light-message-section" id="lightMessageSection">
                <div class="character-name" id="lightTitle">✨ Word of Light</div>
                <div class="light-message" id="lightMessage"></div>
            </div>
            
            <div class="navigation-section" id="navigationSection">
                <div class="navigation-title" id="navigationTitle">💌 Portal 05 Complete</div>
                <div class="navigation-message" id="navigationMessage"></div>
                <div class="navigation-buttons">
                    <button class="nav-btn primary" id="nextPortalBtn">Continue to Portal 06</button>
                    <button class="nav-btn" id="stayPortalBtn">Stay with this letter</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="input-fixed-bottom">
        <div class="input-container">
            <div class="input-prefix">></div>
            <textarea class="user-textarea" 
                      id="userTextarea" 
                      placeholder="At the end of your emotional journey, what letter would you like to leave for yourself? (Press Enter to send)"
                      rows="1"
                      maxlength="800"></textarea>
        </div>
    </div>

    <script>
        // Global state management
        let state = {
            db: null,
            auth: null,
            firebaseInitialized: false,
            currentUser: null,
            currentLanguage: 'en',
            userResponse: '',
            journeyStarted: false,
            currentTypingElement: null,
            typingIntervals: [],
            awaitingSecondResponse: false,
            userResponses: [] // Store responses in memory temporarily
        };
        
        // Portal navigation configuration
        const portalConfig = {
            currentPortal: "v5-05",
            nextPortal: "v5-06",
            nextPortalFile: "temarix_v05_06.html" // Centralized file naming
        };
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBjsINSqPUGdpRPRMYiVg6SkVJJOk9YGsY",
            authDomain: "canal-vivo-chat.firebaseapp.com",
            projectId: "canal-vivo-chat",
            storageBucket: "canal-vivo-chat.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdefghijklmnopqr"
        };
        
        // Initialize Firebase with error handling
        function initializeFirebase() {
            return new Promise((resolve) => {
                try {
                    if (typeof firebase !== 'undefined') {
                        firebase.initializeApp(firebaseConfig);
                        state.db = firebase.firestore();
                        state.auth = firebase.auth();
                        state.firebaseInitialized = true;
                        
                        // Check authentication state
                        state.auth.onAuthStateChanged((user) => {
                            if (user) {
                                state.currentUser = user;
                            } else {
                                // Create anonymous user
                                state.currentUser = {
                                    uid: 'anonymous-' + Date.now(),
                                    email: 'anonymous@temarix.com',
                                    isAnonymous: true
                                };
                            }
                            showConnectionStatus(true);
                        });
                        
                        console.log('Firebase initialized successfully');
                    } else {
                        console.log('Firebase SDK not loaded');
                        // Create anonymous user
                        state.currentUser = {
                            uid: 'anonymous-' + Date.now(),
                            email: 'anonymous@temarix.com',
                            isAnonymous: true
                        };
                        showConnectionStatus(false);
                    }
                } catch (error) {
                    console.error('Firebase initialization failed:', error);
                    // Create anonymous user
                    state.currentUser = {
                        uid: 'anonymous-' + Date.now(),
                        email: 'anonymous@temarix.com',
                        isAnonymous: true
                    };
                    showConnectionStatus(false);
                }
                resolve(); // Always resolve to continue execution
            });
        }
        
        // Show connection status to user
        function showConnectionStatus(isOnline) {
            // Remove existing status if any
            const existingStatus = document.querySelector('.connection-status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            if (!isOnline) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'connection-status';
                statusDiv.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: rgba(255, 107, 107, 0.9);
                    color: white;
                    padding: 8px 15px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-family: 'Courier New', monospace;
                    z-index: 1000;
                    opacity: 0.8;
                `;
                statusDiv.textContent = state.currentLanguage === 'ko' ? '오프라인 모드' : 
                                       state.currentLanguage === 'pt' ? 'Modo offline' : 'Offline mode';
                document.body.appendChild(statusDiv);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.remove();
                    }
                }, 5000);
            }
        }

        // Translations object
        const translations = {
            ko: {
                title: "Temarix V5 - Portal 05: 내가 나에게 남긴 편지",
                logoSubtitle: "감정 연금술",
                portalMainTitle: "Portal 05: 내가 나에게 남긴 편지",
                portalSubtitle: "자비와 회복의 메시지",
                portalIntro: "💌 \"이제까지의 감정 여정 끝에,\n당신은 지금의 자신에게 어떤 편지를 남기고 싶나요?\"\n\n\"자비와 회복의 시선으로,\n과거의 당신에게 건네는 한 통의 편지를 써보세요.\"",
                emotionalBridge: "편지는 시간을 건너는 다리입니다.\n과거의 아픔을 현재의 자비로 감싸주세요...",
                followUpQuestion: "이 편지를 매일 아침 나에게 다시 읽어줄 수 있나요?\n그리고... 언젠가 누군가에게도 전하고 싶나요?",
                lightTitle: "✨ 빛의 한마디",
                lightMessage: "그 편지는 당신 안에서 계속 살아 있어요.\n그건 기억이 아니라, 자비의 맥박이에요.",
                navigationTitle: "💌 Portal 05 완료",
                navigationMessage: "당신은 자신에게 편지를 썼습니다.\n\n그 편지는 과거를 치유하고 미래를 여는 자비의 언어였습니다.\n이제 용서와 수용의 말을 넘어서 삶 전체를 새로이 바라볼 준비가 되었습니다.\n\n자비는 외부에서 오는 게 아니라, 당신 내면에서 꺼낸 것입니다.",
                nextPortalBtn: "Portal 06으로 이어가기",
                stayPortalBtn: "이 편지와 더 머물기",
                inputPlaceholder: "감정 여정의 끝에서, 당신은 자신에게 어떤 편지를 남기고 싶나요? (Enter로 전송)",
                youLabel: "당신",
                waitingMessage: "응답을 기다리는 중...",
                confirmNextPortal: "Portal 06: 비난의 그림자를 지나며로 이동하시겠습니까?",
                confirmStay: "이 편지와 더 머물며 자비를 깊이 느끼시겠습니까?",
                transitionMessage: "새로운 여정이 시작됩니다..."
            },
            en: {
                title: "Temarix V5 - Portal 05: The Letter I Left for Myself",
                logoSubtitle: "Emotional Alchemy",
                portalMainTitle: "Portal 05: The Letter I Left for Myself",
                portalSubtitle: "A message of compassion and recovery",
                portalIntro: "💌 \"At the end of your emotional journey so far,\nwhat letter would you like to leave for yourself?\"\n\n\"With a perspective of compassion and recovery,\nwrite a letter to your past self.\"",
                emotionalBridge: "A letter is a bridge that crosses time.\nWrap your past pain with present compassion...",
                followUpQuestion: "Can you read this letter to yourself again every morning?\nAnd... would you like to share it with someone someday?",
                lightTitle: "✨ Word of Light",
                lightMessage: "That letter continues to live within you.\nIt's not just a memory, but the heartbeat of compassion.",
                navigationTitle: "💌 Portal 05 Complete",
                navigationMessage: "You have written a letter to yourself.\n\nThat letter was the language of compassion that heals the past and opens the future.\nNow you are ready to look at life anew, beyond words of forgiveness and acceptance.\n\nCompassion doesn't come from outside, but from what you've drawn from within.",
                nextPortalBtn: "Continue to Portal 06",
                stayPortalBtn: "Stay with this letter",
                inputPlaceholder: "At the end of your emotional journey, what letter would you like to leave for yourself? (Press Enter to send)",
                youLabel: "You",
                waitingMessage: "Waiting for response...",
                confirmNextPortal: "Do you want to continue to Portal 06: Passing Through the Shadow of Criticism?",
                confirmStay: "Do you want to stay longer with this letter to deeply feel compassion?",
                transitionMessage: "A new journey begins..."
            },
            pt: {
                title: "Temarix V5 - Portal 05: A Carta que Deixei para Mim Mesmo",
                logoSubtitle: "Alquimia Emocional",
                portalMainTitle: "Portal 05: A Carta que Deixei para Mim Mesmo",
                portalSubtitle: "Uma mensagem de compaixão e recuperação",
                portalIntro: "💌 \"No final de sua jornada emocional até agora,\nque carta você gostaria de deixar para si mesmo?\"\n\n\"Com uma perspectiva de compaixão e recuperação,\nescreva uma carta para seu eu do passado.\"",
                emotionalBridge: "Uma carta é uma ponte que atravessa o tempo.\nEnvolva sua dor passada com compaixão presente...",
                followUpQuestion: "Você pode ler esta carta para si mesmo novamente todas as manhãs?\nE... gostaria de compartilhá-la com alguém algum dia?",
                lightTitle: "✨ Palavra de Luz",
                lightMessage: "Essa carta continua viva dentro de você.\nNão é apenas uma lembrança, mas o batimento cardíaco da compaixão.",
                navigationTitle: "💌 Portal 05 Completo",
                navigationMessage: "Você escreveu uma carta para si mesmo.\n\nEssa carta foi a linguagem da compaixão que cura o passado e abre o futuro.\nAgora você está pronto para olhar a vida de forma renovada, além das palavras de perdão e aceitação.\n\nA compaixão não vem de fora, mas do que você tirou de dentro.",
                nextPortalBtn: "Continuar para Portal 06",
                stayPortalBtn: "Ficar com esta carta",
                inputPlaceholder: "No final de sua jornada emocional, que carta você gostaria de deixar para si mesmo? (Enter para enviar)",
                youLabel: "Você",
                waitingMessage: "Aguardando resposta...",
                confirmNextPortal: "Deseja continuar para Portal 06: Passando pela Sombra da Crítica?",
                confirmStay: "Deseja ficar mais tempo com esta carta para sentir profundamente a compaixão?",
                transitionMessage: "Uma nova jornada começa..."
            }
        };
        
        // Character definitions
        const characters = [
            { name: "Noah", emoji: "🧑‍🦱", text: {
                ko: "그 편지는 말보다 더 깊은 손짓이야.\n너는 이제 너를 안을 수 있는 사람이 되었어.",
                en: "That letter is a gesture deeper than words.\nYou have now become someone who can embrace yourself.",
                pt: "Essa carta é um gesto mais profundo que as palavras.\nVocê agora se tornou alguém que pode abraçar a si mesmo."
            }},
            { name: "Ely", emoji: "🧝‍♀️", text: {
                ko: "그 말들은 묵은 그림자를 씻어내는 빗물 같아요.\n당신은 당신에게 비를 허락했어요.",
                en: "Those words are like rain washing away old shadows.\nYou have allowed rain to fall upon yourself.",
                pt: "Essas palavras são como chuva lavando velhas sombras.\nVocê permitiu que a chuva caísse sobre si mesmo."
            }},
            { name: "Sora", emoji: "🧕", text: {
                ko: "그동안 아무도 안아주지 않았던 당신을...\n이제는 당신이 안아주었네요.",
                en: "You, who no one embraced for so long...\nNow you have embraced yourself.",
                pt: "Você, que ninguém abraçou por tanto tempo...\nAgora você abraçou a si mesmo."
            }},
            { name: "Kael", emoji: "🧙", text: {
                ko: "그 편지는 시간을 건넌 주문이야.\n과거의 상처에 새 문을 여는 열쇠.",
                en: "That letter is a spell that crosses time.\nA key that opens new doors to past wounds.",
                pt: "Essa carta é um feitiço que atravessa o tempo.\nUma chave que abre novas portas para feridas passadas."
            }},
            { name: "Mira", emoji: "🧑‍🎨", text: {
                ko: "이 편지엔 당신의 모든 색이 담겨 있어요.\n눈물, 침묵, 희망까지도.",
                en: "This letter contains all your colors.\nTears, silence, and hope too.",
                pt: "Esta carta contém todas as suas cores.\nLágrimas, silêncio e esperança também."
            }},
            { name: "Cris", emoji: "🦸‍♂️", text: {
                ko: "강하다는 건 견디는 게 아니라,\n쓰러졌던 자신을 다시 일으키는 거야.\n그리고 지금, 당신이 그걸 해냈어.",
                en: "Being strong isn't about enduring,\nbut about lifting up the self that had fallen.\nAnd now, you've done it.",
                pt: "Ser forte não é sobre resistir,\nmas sobre levantar o eu que havia caído.\nE agora, você conseguiu."
            }},
            { name: "Enya", emoji: "🧑‍🚀", text: {
                ko: "우주는 당신의 그 편지를 들었을 거예요.\n그 울림은 혼자가 아니니까.",
                en: "The universe must have heard that letter of yours.\nThat resonance is not alone.",
                pt: "O universo deve ter ouvido essa sua carta.\nEssa ressonância não está sozinha."
            }},
            { name: "Lian", emoji: "🧘", text: {
                ko: "자비는 외부에서 오는 게 아니에요.\n당신은 지금, 그 자비를 '내면에서' 꺼낸 거예요.",
                en: "Compassion doesn't come from outside.\nYou have now drawn that compassion 'from within'.",
                pt: "A compaixão não vem de fora.\nVocê agora tirou essa compaixão 'de dentro'."
            }}
        ];

        // Letter analysis function
        function analyzeLetterTone(userInput) {
            const input = userInput.toLowerCase();
            
            const toneKeywords = {
                healing: ['heal', 'better', 'grow', 'recover', 'strong', '치유', '나아지', '성장', '회복', '강해', 'cura', 'melhor', 'crescer', 'recuperar', 'forte'],
                forgiveness: ['sorry', 'forgive', 'understand', 'accept', '미안', '용서', '이해', '받아들', 'perdão', 'desculpa', 'perdoar', 'entender', 'aceitar'],
                love: ['love', 'care', 'precious', 'worthy', 'beautiful', '사랑', '소중', '아름다', '가치', 'amor', 'cuidar', 'precioso', 'valioso', 'bonito'],
                encouragement: ['keep', 'continue', 'try', 'believe', 'hope', '계속', '노력', '믿어', '희망', 'continuar', 'tentar', 'acreditar', 'esperança'],
                gratitude: ['thank', 'grateful', 'appreciate', 'glad', '고마워', '감사', '다행', 'obrigado', 'grato', 'agradecer', 'alegre'],
                peace: ['peace', 'calm', 'rest', 'quiet', 'safe', '평화', '고요', '휴식', '안전', 'paz', 'calmo', 'descanso', 'quieto', 'seguro'],
                strength: ['brave', 'courage', 'warrior', 'fighter', 'survivor', '용기', '용감', '전사', '생존', 'corajoso', 'coragem', 'guerreiro', 'lutador', 'sobrevivente'],
                wisdom: ['learn', 'wise', 'understand', 'know', 'realize', '배우', '지혜', '깨달', '알게', 'aprender', 'sábio', 'entender', 'saber', 'perceber']
            };
            
            let detectedTones = [];
            for (const [tone, keywords] of Object.entries(toneKeywords)) {
                for (const keyword of keywords) {
                    if (input.includes(keyword)) {
                        detectedTones.push(tone);
                        break;
                    }
                }
            }
            
            if (detectedTones.length === 0) {
                detectedTones = ['general'];
            }
            
            return detectedTones[0];
        }
        
        // Response characters with tone-based responses
        const responseCharacters = [
            {
                name: "Lian", emoji: "🧘",
                getResponse: (userInput, lang) => {
                    const tone = analyzeLetterTone(userInput);
                    
                    const responses = {
                        ko: {
                            healing: "그 마음은 이미 길이 되었어요.\n이제 당신은, 스스로를 인도할 수 있는 사람이에요.",
                            forgiveness: "용서는 말이었고, 편지는 행동이에요.\n당신은 이제, 자비를 '살아낸' 존재예요.",
                            love: "사랑의 편지를 자신에게 쓸 수 있는 사람은\n이미 사랑을 아는 사람이에요.",
                            encouragement: "그 격려는 미래를 향한 씨앗이에요.\n당신 안에서 계속 자랄 거예요.",
                            gratitude: "감사는 과거를 치유하고 현재를 밝히는\n가장 순수한 빛이에요.",
                            peace: "평화로운 편지는 당신이 이미 평화를 찾았다는\n증거예요.",
                            strength: "힘의 편지를 쓴 당신은\n이제 진짜 힘이 무엇인지 아는 사람이에요.",
                            wisdom: "지혜의 편지는 당신이 여정을 통해\n진짜 배움을 얻었다는 뜻이에요.",
                            general: "그 마음은 이미 길이 되었어요.\n이제 당신은, 스스로를 인도할 수 있는 사람이에요."
                        },
                        en: {
                            healing: "That heart has already become a path.\nNow you are someone who can guide yourself.",
                            forgiveness: "Forgiveness was words, and the letter is action.\nYou are now a being who has 'lived' compassion.",
                            love: "Someone who can write a love letter to themselves\nalready knows love.",
                            encouragement: "That encouragement is a seed for the future.\nIt will keep growing within you.",
                            gratitude: "Gratitude is the purest light that heals the past\nand brightens the present.",
                            peace: "A peaceful letter is proof that you have\nalready found peace.",
                            strength: "You who wrote a letter of strength\nnow know what real strength is.",
                            wisdom: "A letter of wisdom means you have gained\nreal learning through your journey.",
                            general: "That heart has already become a path.\nNow you are someone who can guide yourself."
                        },
                        pt: {
                            healing: "Esse coração já se tornou um caminho.\nAgora você é alguém que pode se guiar.",
                            forgiveness: "O perdão eram palavras, e a carta é ação.\nVocê agora é um ser que 'viveu' a compaixão.",
                            love: "Alguém que pode escrever uma carta de amor para si mesmo\njá conhece o amor.",
                            encouragement: "Esse encorajamento é uma semente para o futuro.\nContinuará crescendo dentro de você.",
                            gratitude: "A gratidão é a luz mais pura que cura o passado\ne ilumina o presente.",
                            peace: "Uma carta pacífica é prova de que você já\nencontrou a paz.",
                            strength: "Você que escreveu uma carta de força\nagora sabe o que é força real.",
                            wisdom: "Uma carta de sabedoria significa que você obteve\naprendizado real através de sua jornada.",
                            general: "Esse coração já se tornou um caminho.\nAgora você é alguém que pode se guiar."
                        }
                    };
                    
                    return responses[lang][tone] || responses[lang]['general'];
                }
            },
            {
                name: "Sora", emoji: "🧕",
                getResponse: (userInput, lang) => {
                    const tone = analyzeLetterTone(userInput);
                    
                    const responses = {
                        ko: {
                            healing: "그 편지는 당신 안에서 계속 살아 있어요.\n그건 기억이 아니라, 자비의 맥박이에요.",
                            forgiveness: "용서의 편지는 시간을 거슬러\n과거의 상처까지 어루만질 거예요.",
                            love: "사랑의 편지는 당신을 둘러싼\n모든 어둠을 밝힐 거예요.",
                            encouragement: "격려의 편지는 당신이 포기하고 싶을 때마다\n다시 일어설 힘을 줄 거예요.",
                            gratitude: "감사의 편지는 당신의 모든 경험을\n축복으로 바꿀 거예요.",
                            peace: "평화의 편지는 당신 안의 모든 전쟁을\n끝낼 거예요.",
                            strength: "힘의 편지는 당신을 어떤 시련에서도\n지켜줄 방패가 될 거예요.",
                            wisdom: "지혜의 편지는 당신을 길잃지 않게 하는\n나침반이 될 거예요.",
                            general: "그 편지는 당신 안에서 계속 살아 있어요.\n그건 기억이 아니라, 자비의 맥박이에요."
                        },
                        en: {
                            healing: "That letter continues to live within you.\nIt's not just a memory, but the heartbeat of compassion.",
                            forgiveness: "A letter of forgiveness will reach back through time\nto soothe even past wounds.",
                            love: "A letter of love will brighten\nall the darkness surrounding you.",
                            encouragement: "A letter of encouragement will give you strength\nto rise again whenever you want to give up.",
                            gratitude: "A letter of gratitude will transform\nall your experiences into blessings.",
                            peace: "A letter of peace will end\nall wars within you.",
                            strength: "A letter of strength will become a shield\nthat protects you from any trial.",
                            wisdom: "A letter of wisdom will become a compass\nthat keeps you from losing your way.",
                            general: "That letter continues to live within you.\nIt's not just a memory, but the heartbeat of compassion."
                        },
                        pt: {
                            healing: "Essa carta continua viva dentro de você.\nNão é apenas uma lembrança, mas o batimento cardíaco da compaixão.",
                            forgiveness: "Uma carta de perdão alcançará o passado no tempo\npara curar até feridas antigas.",
                            love: "Uma carta de amor iluminará\ntoda a escuridão que te cerca.",
                            encouragement: "Uma carta de encorajamento te dará força\npara se levantar sempre que quiser desistir.",
                            gratitude: "Uma carta de gratidão transformará\ntodas suas experiências em bênçãos.",
                            peace: "Uma carta de paz terminará\ntodas as guerras dentro de você.",
                            strength: "Uma carta de força se tornará um escudo\nque te protegerá de qualquer provação.",
                            wisdom: "Uma carta de sabedoria se tornará uma bússola\nque te impedirá de se perder.",
                            general: "Essa carta continua viva dentro de você.\nNão é apenas uma lembrança, mas o batimento cardíaco da compaixão."
                        }
                    };
                    
                    return responses[lang][tone] || responses[lang]['general'];
                }
            },
            {
                name: "Ely", emoji: "🧝‍♀️",
                getResponse: (userInput, lang) => {
                    const tone = analyzeLetterTone(userInput);
                    
                    const responses = {
                        ko: {
                            healing: "용서는 타인을 향한 게 아니라,\n그렇게 나를 미워하던 나를 받아들이는 일부터 시작돼요.",
                            forgiveness: "그 편지는 단순한 위로가 아니라,\n존재의 귀환이에요.",
                            love: "사랑의 편지를 쓴 순간,\n당신은 사랑 그 자체가 되었어요.",
                            encouragement: "격려의 편지는 당신이 스스로에게\n가장 좋은 친구가 되었다는 뜻이에요.",
                            gratitude: "감사의 편지는 모든 아픔을\n선물로 바꾸는 연금술이에요.",
                            peace: "평화의 편지는 당신이 내면의 고향에\n도착했다는 신호예요.",
                            strength: "힘의 편지는 당신이 더 이상\n외부의 인정을 기다리지 않는다는 선언이에요.",
                            wisdom: "지혜의 편지는 당신이 경험을\n이해로 바꾼 증거예요.",
                            general: "용서는 타인을 향한 게 아니라,\n그렇게 나를 미워하던 나를 받아들이는 일부터 시작돼요."
                        },
                        en: {
                            healing: "Forgiveness isn't toward others,\nbut starts with accepting the self that used to hate me.",
                            forgiveness: "That letter is not simple comfort,\nbut the return of existence.",
                            love: "The moment you wrote a letter of love,\nyou became love itself.",
                            encouragement: "A letter of encouragement means you have become\nyour own best friend.",
                            gratitude: "A letter of gratitude is alchemy that transforms\nall pain into gifts.",
                            peace: "A letter of peace is a signal that you have\narrived at your inner homeland.",
                            strength: "A letter of strength is a declaration that you no longer\nwait for external validation.",
                            wisdom: "A letter of wisdom is proof that you have transformed\nexperience into understanding.",
                            general: "Forgiveness isn't toward others,\nbut starts with accepting the self that used to hate me."
                        },
                        pt: {
                            healing: "O perdão não é direcionado aos outros,\nmas começa aceitando o eu que costumava me odiar.",
                            forgiveness: "Essa carta não é simples conforto,\nmas o retorno da existência.",
                            love: "No momento em que você escreveu uma carta de amor,\nvocê se tornou o próprio amor.",
                            encouragement: "Uma carta de encorajamento significa que você se tornou\nseu próprio melhor amigo.",
                            gratitude: "Uma carta de gratidão é alquimia que transforma\ntoda dor em presentes.",
                            peace: "Uma carta de paz é um sinal de que você chegou\nà sua pátria interior.",
                            strength: "Uma carta de força é uma declaração de que você não espera mais\nvalidação externa.",
                            wisdom: "Uma carta de sabedoria é prova de que você transformou\nexperiência em compreensão.",
                            general: "O perdão não é direcionado aos outros,\nmas começa aceitando o eu que costumava me odiar."
                        }
                    };
                    
                    return responses[lang][tone] || responses[lang]['general'];
                }
            }
        ];
        
        // Typewriter effect
        function typewriterEffect(element, text, speed = 80) {
            return new Promise((resolve) => {
                if (state.currentTypingElement) {
                    state.currentTypingElement.classList.remove('typing-cursor');
                }
                
                let i = 0;
                element.innerHTML = '';
                element.classList.add('typing-cursor');
                state.currentTypingElement = element;
                
                const typingInterval = setInterval(() => {
                    if (!document.contains(element)) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        state.currentTypingElement = null;
                        resolve();
                        return;
                    }
                    
                    element.innerHTML += text.charAt(i);
                    i++;
                    
                    if (i % 10 === 0) {
                        scrollToFollowTyping(element);
                    }
                    
                    if (i === text.length) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        state.currentTypingElement = null;
                        resolve();
                    }
                }, speed);
                
                state.typingIntervals.push(typingInterval);
            });
        }
        
        // Clear all typing effects
        function clearAllTypingEffects() {
            state.typingIntervals.forEach(interval => clearInterval(interval));
            state.typingIntervals = [];
            
            if (state.currentTypingElement) {
                state.currentTypingElement.classList.remove('typing-cursor');
                state.currentTypingElement = null;
            }
        }
        
        // Scroll functions
        function scrollToFollowTyping(element) {
            const mainContent = document.getElementById('mainContent');
            const elementRect = element.getBoundingClientRect();
            const containerRect = mainContent.getBoundingClientRect();
            
            if (elementRect.bottom > containerRect.bottom - 150) {
                const scrollTop = mainContent.scrollTop;
                const elementOffsetTop = element.offsetTop;
                const targetScroll = elementOffsetTop - (containerRect.height / 2);
                
                mainContent.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }
        
        function scrollToElement(element) {
            const mainContent = document.getElementById('mainContent');
            const elementOffsetTop = element.offsetTop;
            const containerHeight = mainContent.clientHeight;
            const targetScroll = elementOffsetTop - (containerHeight / 3);
            
            mainContent.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }
        
        // Language management
        function updateLanguageButtons(lang) {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateStaticTranslations(lang) {
            const t = translations[lang];
            document.title = t.title;
            document.getElementById('logoSubtitle').textContent = t.logoSubtitle;
            document.getElementById('portalMainTitle').textContent = t.portalMainTitle;
            document.getElementById('portalSubtitle').textContent = t.portalSubtitle;
            document.getElementById('lightTitle').textContent = t.lightTitle;
            document.getElementById('navigationTitle').textContent = t.navigationTitle;
            document.getElementById('nextPortalBtn').textContent = t.nextPortalBtn;
            document.getElementById('stayPortalBtn').textContent = t.stayPortalBtn;
            document.getElementById('userTextarea').placeholder = t.inputPlaceholder;
        }
        
        function changeLanguage(lang) {
            if (!translations[lang] || state.currentLanguage === lang) return;
            
            state.currentLanguage = lang;
            updateLanguageButtons(lang);
            updateStaticTranslations(lang);
            
            if (state.journeyStarted) {
                resetJourney();
                setTimeout(() => {
                    startPortalSequence();
                }, 1000);
            }
        }
        
        // Journey management
        function resetJourney() {
            clearAllTypingEffects();
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            
            const sectionsToReset = [
                'portalIntroSection', 'characterResponsesSection', 
                'followUpSection', 'userInputSection',
                'userReactionsSection', 'lightMessageSection', 'navigationSection'
            ];
            
            sectionsToReset.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('show');
                    section.style.opacity = '0';
                    if (sectionId === 'characterResponsesSection' || 
                        sectionId === 'userInputSection' || 
                        sectionId === 'userReactionsSection') {
                        section.innerHTML = '';
                    }
                }
            });
            
            document.getElementById('portalIntro').innerHTML = '';
            document.getElementById('followUpQuestion').innerHTML = '';
            document.getElementById('lightMessage').innerHTML = '';
            document.getElementById('navigationMessage').innerHTML = '';
            
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[state.currentLanguage].inputPlaceholder;
            
            document.getElementById('mainContent').scrollTop = 0;
            state.userResponse = '';
            state.currentTypingElement = null;
            state.awaitingSecondResponse = false;
        }
        
        // Save response to database or memory
        async function saveResponse(inputText, step) {
            const responseData = {
                portal: portalConfig.currentPortal,
                resposta: inputText,
                step: step,
                data: new Date().toISOString(),
                idioma: state.currentLanguage,
                userId: state.currentUser ? state.currentUser.uid : 'anonymous',
                userEmail: state.currentUser ? state.currentUser.email : 'anonymous@temarix.com'
            };
            
            if (state.firebaseInitialized && state.db) {
                try {
                    await state.db.collection("temarix_v5_respostas").add({
                        ...responseData,
                        timestamp: firebase.firestore.Timestamp.now()
                    });
                    console.log('Response saved to Firestore');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                    // Store temporarily in memory and show offline status
                    state.userResponses.push(responseData);
                    showConnectionStatus(false);
                }
            } else {
                // Store temporarily in memory if Firebase not available
                state.userResponses.push(responseData);
                console.log('Response stored in memory:', responseData);
            }
        }
        
        // User input processing
        async function processUserInput(inputText) {
            state.userResponse = inputText;
            
            await saveResponse(inputText, state.awaitingSecondResponse ? "second" : "first");
            
            disableUserInput();
            showUserResponse(inputText);
            
            setTimeout(() => {
                if (!state.awaitingSecondResponse) {
                    showUserReactions(inputText);
                } else {
                    showSecondUserReactions(inputText);
                }
            }, 1000);
        }
        
        function disableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = true;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[state.currentLanguage].waitingMessage;
        }
        
        function enableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.placeholder = translations[state.currentLanguage].inputPlaceholder;
            
            setTimeout(() => {
                userTextarea.focus();
            }, 100);
        }
        
        function showUserResponse(text) {
            const inputSection = document.getElementById('userInputSection');
            const userDiv = document.createElement('div');
            userDiv.className = 'user-response';
            const youLabel = translations[state.currentLanguage].youLabel;
            userDiv.innerHTML = '<strong>' + youLabel + ':</strong> "' + text + '"';
            inputSection.appendChild(userDiv);
            inputSection.classList.add('show');
            
            setTimeout(() => {
                scrollToElement(inputSection);
            }, 100);
        }
        
        // Show character reactions
        async function showUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            reactionsSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[state.currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showFollowUpQuestion();
            }, 2000);
        }
        
        async function showFollowUpQuestion() {
            const followUpSection = document.getElementById('followUpSection');
            const followUpQuestionEl = document.getElementById('followUpQuestion');
            
            followUpSection.classList.add('show');
            
            await typewriterEffect(followUpQuestionEl, translations[state.currentLanguage].followUpQuestion, 50);
            
            setTimeout(() => {
                state.awaitingSecondResponse = true;
                enableUserInput();
            }, 1500);
        }
        
        async function showSecondUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            
            for (let i = 0; i < responseCharacters.length; i++) {
                const char = responseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, state.currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < responseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showLightMessage();
            }, 2000);
        }
        
        async function showLightMessage() {
            const lightSection = document.getElementById('lightMessageSection');
            const lightMessageEl = document.getElementById('lightMessage');
            
            lightSection.classList.add('show');
            
            await typewriterEffect(lightMessageEl, translations[state.currentLanguage].lightMessage, 60);
            
            setTimeout(() => {
                showNavigationSection();
            }, 2000);
        }
        
        async function showNavigationSection() {
            const navigationSection = document.getElementById('navigationSection');
            const navigationMessage = document.getElementById('navigationMessage');
            
            navigationSection.classList.add('show');
            
            const messageText = translations[state.currentLanguage].navigationMessage;
            await typewriterEffect(navigationMessage, messageText, 50);
            
            setTimeout(() => {
                scrollToElement(navigationSection);
            }, 500);
        }
        
        // Portal sequence
        async function startPortalSequence() {
            console.log('Starting portal sequence...');
            setTimeout(() => {
                showIntro();
            }, 1000);
        }
        
        async function showIntro() {
            console.log('Showing intro...');
            const introSection = document.getElementById('portalIntroSection');
            const introElement = document.getElementById('portalIntro');
            
            if (!introSection || !introElement) {
                console.error('Intro elements not found!');
                return;
            }
            
            introSection.classList.add('show');
            
            const introText = translations[state.currentLanguage].portalIntro;
            console.log('Intro text:', introText);
            
            await typewriterEffect(introElement, introText, 60);
            
            // Add emotional bridge before showing characters
            setTimeout(async () => {
                await showEmotionalBridge();
            }, 2000);
        }
        
        async function showEmotionalBridge() {
            const introElement = document.getElementById('portalIntro');
            const bridgeText = '\n\n' + translations[state.currentLanguage].emotionalBridge;
            
            // Add bridge text with typing effect
            await typewriterEffect({
                innerHTML: '',
                classList: { add: () => {}, remove: () => {} },
                style: {},
                textContent: '',
                appendChild: () => {},
                offsetTop: 0
            }, '', 0); // Dummy element for delay
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Create new paragraph for bridge
            const bridgeP = document.createElement('p');
            bridgeP.style.cssText = `
                margin-top: 30px;
                font-style: italic;
                color: #ff9999;
                font-size: 18px;
                line-height: 1.8;
            `;
            introElement.appendChild(bridgeP);
            
            await typewriterEffect(bridgeP, bridgeText.trim(), 50);
            
            setTimeout(() => {
                showCharacterResponses();
            }, 2000);
        }
        
        async function showCharacterResponses() {
            const responseSection = document.getElementById('characterResponsesSection');
            responseSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                responseSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[state.currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                enableUserInput();
            }, 2000);
        }
        
        // Custom confirm dialog with translated text
        function showConfirmDialog(message, callback) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: 'Courier New', monospace;
            `;
            
            // Create modal content
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #222;
                border: 2px solid #ff6b6b;
                padding: 30px;
                max-width: 400px;
                text-align: center;
                color: white;
            `;
            
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.cssText = `
                margin-bottom: 20px;
                line-height: 1.6;
                font-size: 16px;
            `;
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 15px;
                justify-content: center;
            `;
            
            const yesBtn = document.createElement('button');
            const noBtn = document.createElement('button');
            
            const buttonStyle = `
                background: #444;
                color: white;
                border: 1px solid #ff6b6b;
                padding: 10px 20px;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                font-size: 14px;
            `;
            
            yesBtn.style.cssText = buttonStyle + 'background: #ff6b6b;';
            noBtn.style.cssText = buttonStyle;
            
            // Set button texts based on current language
            const t = translations[state.currentLanguage];
            yesBtn.textContent = state.currentLanguage === 'ko' ? '예' : 
                                state.currentLanguage === 'pt' ? 'Sim' : 'Yes';
            noBtn.textContent = state.currentLanguage === 'ko' ? '아니오' : 
                               state.currentLanguage === 'pt' ? 'Não' : 'No';
            
            // Event handlers
            yesBtn.onclick = () => {
                document.body.removeChild(overlay);
                callback(true);
            };
            
            noBtn.onclick = () => {
                document.body.removeChild(overlay);
                callback(false);
            };
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    callback(false);
                }
            };
            
            // Escape key handler
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    document.body.removeChild(overlay);
                    document.removeEventListener('keydown', escHandler);
                    callback(false);
                }
            };
            document.addEventListener('keydown', escHandler);
            
            // Build and show modal
            buttonContainer.appendChild(yesBtn);
            buttonContainer.appendChild(noBtn);
            modal.appendChild(messageP);
            modal.appendChild(buttonContainer);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Focus on Yes button
            yesBtn.focus();
        }
        
        // Event setup
        function setupLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    changeLanguage(this.dataset.lang);
                });
            });
        }
        
        function setupTextareaAutoResize() {
            const textarea = document.getElementById('userTextarea');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 96) + 'px';
            });
        }
        
        // Smooth portal transition with visual effects
        function createPortalTransition(callback) {
            // Create transition overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(45deg, #000 0%, #111 50%, #000 100%);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 20000;
                opacity: 0;
                transition: opacity 1s ease-in-out;
                font-family: 'Courier New', monospace;
            `;
            
            // Create transition message
            const message = document.createElement('div');
            message.style.cssText = `
                color: #ff6b6b;
                font-size: 24px;
                text-align: center;
                margin-bottom: 30px;
                opacity: 0;
                transform: translateY(20px);
                transition: all 0.8s ease-out;
            `;
            message.textContent = translations[state.currentLanguage].transitionMessage;
            
            // Create loading animation
            const loader = document.createElement('div');
            loader.style.cssText = `
                width: 60px;
                height: 60px;
                border: 3px solid #333;
                border-top: 3px solid #ff6b6b;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                opacity: 0;
                transition: opacity 0.8s ease-out 0.3s;
            `;
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);
            
            overlay.appendChild(message);
            overlay.appendChild(loader);
            document.body.appendChild(overlay);
            
            // Start transition animation
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 10);
            
            setTimeout(() => {
                message.style.opacity = '1';
                message.style.transform = 'translateY(0)';
                loader.style.opacity = '1';
            }, 300);
            
            // Complete transition and redirect
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(overlay);
                    document.head.removeChild(style);
                    callback();
                }, 1000);
            }, 2500);
        }
        
        function setupInputEvents() {
            const userTextarea = document.getElementById('userTextarea');
            
            userTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const inputValue = this.value.trim();
                    
                    if (inputValue) {
                        processUserInput(inputValue);
                    }
                }
            });
            
            // Next portal button with transition
            document.getElementById('nextPortalBtn').addEventListener('click', function() {
                const t = translations[state.currentLanguage];
                showConfirmDialog(t.confirmNextPortal, (confirmed) => {
                    if (confirmed) {
                        // Save completion status if Firebase available
                        if (state.firebaseInitialized && state.db) {
                            state.db.collection("temarix_v5_progress").add({
                                userId: state.currentUser.uid,
                                portal: portalConfig.currentPortal,
                                status: "complete",
                                timestamp: firebase.firestore.Timestamp.now()
                            }).catch(error => console.error('Error saving progress:', error));
                        }
                        
                        // Start transition animation
                        createPortalTransition(() => {
                            window.location.href = `${portalConfig.nextPortalFile}?lang=${state.currentLanguage}`;
                        });
                    }
                });
            });
            
            // Stay button
            document.getElementById('stayPortalBtn').addEventListener('click', function() {
                const t = translations[state.currentLanguage];
                showConfirmDialog(t.confirmStay, (confirmed) => {
                    if (confirmed) {
                        resetJourney();
                        setTimeout(() => {
                            startPortalSequence();
                        }, 1000);
                    }
                });
            });
        }
        
        // Get language from URL
        function getLanguageFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');
            return lang && translations[lang] ? lang : 'en';
        }
        
        // Initialize Temarix
        function initializeTemarix() {
            console.log('Initializing Temarix V5 Portal 05...');
            console.log('Current state:', state);
            
            setupLanguageButtons();
            setupTextareaAutoResize();
            setupInputEvents();
            
            state.journeyStarted = true;
            console.log('Journey started:', state.journeyStarted);
            
            // Start portal sequence immediately
            console.log('Starting portal sequence in 1 second...');
            setTimeout(() => {
                startPortalSequence();
            }, 1000);
        }
        
        // Main initialization
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Temarix V5 Portal 05 DOM loaded');
            
            // Get initial language from URL
            state.currentLanguage = getLanguageFromURL();
            
            // Update UI with selected language immediately
            updateStaticTranslations(state.currentLanguage);
            updateLanguageButtons(state.currentLanguage);
            
            // Initialize Firebase
            await initializeFirebase();
            
            // Start the journey immediately
            initializeTemarix();
        });
    </script>
</body>
</html>