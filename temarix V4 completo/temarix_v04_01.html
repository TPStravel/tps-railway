<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temarix V4 - Portal 01: Fragments of Broken Truth</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 30px;
            background: #000;
            border-bottom: 1px solid #333;
            position: relative;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .logo-title {
            font-size: 26px;
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 4px;
            letter-spacing: 1px;
        }
        
        .logo-subtitle {
            font-size: 15px;
            color: #ccc;
            letter-spacing: 1.5px;
        }
        
        .portal-header-title {
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .portal-main-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }
        
        .portal-subtitle {
            font-size: 18px;
            color: #ff9999;
            letter-spacing: 1.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
        }
        
        .language-buttons {
            display: flex;
            gap: 10px;
        }
        
        .lang-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 18px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .lang-btn:hover {
            background: #666;
        }
        
        .lang-btn.active {
            background: #ff6b6b;
            color: #fff;
        }
        
        .main-content {
            flex: 1;
            max-height: calc(100vh - 80px - 120px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 30px 20px;
            scroll-behavior: smooth;
            position: relative;
        }
        
        .portal-container {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 200vh;
        }
        
        .portal-intro-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 200px;
        }
        
        .portal-intro {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.8;
            white-space: pre-wrap;
            background: none;
            border: none;
            padding: 0;
            text-align: left;
        }
        
        .character-responses-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 800px;
        }
        
        .character-response {
            color: #fff;
            font-size: 18px;
            margin: 40px 0;
            text-align: left;
            opacity: 0;
            white-space: pre-wrap;
            transition: opacity 0.8s ease-in;
            background: none;
            border: none;
            padding: 0;
            min-height: 80px;
        }
        
        .character-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 12px;
            font-size: 18px;
        }
        
        .character-dialogue {
            color: #fff;
            line-height: 1.7;
            font-size: 17px;
            white-space: pre-wrap;
        }
        
        .typing-cursor::after {
            content: '|';
            animation: blink 1s infinite;
            color: #ff6b6b;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .follow-up-section {
            margin: 50px 0;
            opacity: 0;
            min-height: 150px;
        }
        
        .follow-up-question {
            font-size: 22px;
            color: #fff;
            margin-bottom: 30px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.6;
            white-space: pre-wrap;
            text-align: center;
        }
        
        .user-input-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 100px;
        }
        
        .user-response {
            color: #fff;
            margin: 30px 0;
            text-align: left;
            font-size: 18px;
            background: none;
            border: none;
            padding: 0;
            white-space: pre-wrap;
        }
        
        .user-response strong {
            color: #ff6b6b;
            margin-right: 8px;
        }
        
        .user-reactions-section {
            margin: 40px 0;
            opacity: 0;
            min-height: 400px;
        }
        
        .light-message-section {
            margin: 50px 0;
            opacity: 0;
            background: none;
            border: none;
            padding: 0;
            min-height: 100px;
        }
        
        .light-message {
            font-size: 20px;
            color: #ff6b6b;
            line-height: 1.8;
            font-style: italic;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-section {
            margin: 60px 0;
            opacity: 0;
            text-align: center;
            background: none;
            border: none;
            padding: 40px 20px;
            min-height: 300px;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.05);
        }
        
        .navigation-title {
            font-size: 28px;
            color: #ff6b6b;
            margin-bottom: 30px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .navigation-message {
            color: #fff;
            font-size: 20px;
            margin-bottom: 40px;
            line-height: 1.8;
            white-space: pre-wrap;
            text-align: left;
        }
        
        .navigation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .nav-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 20px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            border: 2px solid transparent;
        }
        
        .nav-btn:hover {
            background: #666;
            border-color: #ff6b6b;
        }
        
        .nav-btn.primary {
            background: #ff6b6b;
            color: #fff;
            font-weight: bold;
        }
        
        .nav-btn.primary:hover {
            background: #ff8888;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }
        
        .input-fixed-bottom {
            position: relative;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000;
            border-top: 1px solid #333;
            padding: 25px;
            z-index: 100;
            flex-shrink: 0;
            height: 120px;
        }
        
        .input-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .input-prefix {
            color: #ff6b6b;
            font-size: 20px;
            margin-top: 8px;
            flex-shrink: 0;
        }
        
        .user-textarea {
            background: transparent;
            border: none;
            border-bottom: 1px solid #444;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            width: 100%;
            padding: 12px 8px;
            outline: none;
            resize: none;
            min-height: 32px;
            max-height: 96px;
            line-height: 1.6;
            transition: border-color 0.3s ease;
            overflow-y: auto;
        }
        
        .user-textarea:focus {
            border-bottom-color: #ff6b6b;
        }
        
        .user-textarea::placeholder {
            color: #666;
        }
        
        .user-textarea:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.2);
        }
        
        .main-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .main-content::-webkit-scrollbar-track {
            background: #111;
            border-radius: 6px;
        }
        
        .main-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 6px;
            border: 2px solid #111;
        }
        
        .main-content::-webkit-scrollbar-thumb:hover {
            background: #666;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .show {
            opacity: 1 !important;
            transition: opacity 1s ease-in;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .header-bar {
                padding: 20px 15px;
                height: 70px;
                flex-direction: column;
                gap: 10px;
            }
            
            .main-content {
                max-height: calc(100vh - 70px - 120px);
                padding: 20px 15px;
            }
            
            .logo-title {
                font-size: 22px;
            }
            
            .portal-main-title {
                font-size: 22px;
            }
            
            .portal-subtitle {
                font-size: 16px;
            }
            
            .lang-btn {
                font-size: 12px;
                padding: 8px 14px;
            }
            
            .portal-intro {
                font-size: 18px;
            }
            
            .follow-up-question {
                font-size: 20px;
            }
            
            .character-response {
                font-size: 16px;
            }
            
            .input-fixed-bottom {
                padding: 20px;
            }
            
            .navigation-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-btn {
                width: 100%;
            }
            
            .navigation-title {
                font-size: 24px;
            }
            
            .navigation-message {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="logo-section">
            <div class="logo-title">TEMARIX V4</div>
            <div class="logo-subtitle" id="logoSubtitle">Emotional Alchemy</div>
        </div>
        
        <div class="portal-header-title">
            <div class="portal-main-title" id="portalMainTitle">Portal 01: Fragments of Broken Truth</div>
            <div class="portal-subtitle" id="portalSubtitle">The pieces of truth that cut through memories</div>
        </div>
        
        <div class="header-right">
            <div class="language-buttons">
                <button class="lang-btn" data-lang="ko">KR</button>
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="pt">PT</button>
            </div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="portal-container">
            <div class="portal-intro-section" id="portalIntroSection">
                <div class="portal-intro" id="portalIntro"></div>
            </div>

            <div class="character-responses-section" id="characterResponsesSection">
            </div>

            <div class="follow-up-section" id="followUpSection">
                <div class="follow-up-question" id="followUpQuestion"></div>
            </div>

            <div class="user-input-section" id="userInputSection">
            </div>
            
            <div class="user-reactions-section" id="userReactionsSection">
            </div>

            <div class="light-message-section" id="lightMessageSection">
                <div class="character-name" id="lightTitle">✨ Word of Light</div>
                <div class="light-message" id="lightMessage"></div>
            </div>
            
            <div class="navigation-section" id="navigationSection">
                <div class="navigation-title" id="navigationTitle">🔥 Portal 01 Complete</div>
                <div class="navigation-message" id="navigationMessage"></div>
                <div class="navigation-buttons">
                    <button class="nav-btn primary" id="nextPortalBtn">Continue to Portal 02</button>
                    <button class="nav-btn" id="stayPortalBtn">Stay with these fragments</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="input-fixed-bottom">
        <div class="input-container">
            <div class="input-prefix">></div>
            <textarea class="user-textarea" 
                      id="userTextarea" 
                      placeholder="What is that 'broken truth' that comes to mind? (Press Enter to send)"
                      rows="1"
                      maxlength="500"></textarea>
        </div>
    </div>

    <script>
        let db = null;
        let firebaseInitialized = false;
        let memoryStorage = { mockUser: null };
        
        function initializeFirebase() {
            try {
                if (typeof firebase !== 'undefined') {
                    const firebaseConfig = {
                        apiKey: "AIzaSyBjsINSqPUGdpRPRMYiVg6SkVJJOk9YGsY",
                        authDomain: "canal-vivo-chat.firebaseapp.com",
                        projectId: "canal-vivo-chat",
                        storageBucket: "canal-vivo-chat.appspot.com",
                        messagingSenderId: "123456789",
                        appId: "1:123456789:web:abcdefghijklmnopqr"
                    };
                    firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebaseInitialized = true;
                    console.log('Firebase initialized');
                } else {
                    console.log('Firebase SDK not loaded');
                }
            } catch (error) {
                console.log('Firebase init failed:', error);
            }
        }

        const translations = {
            ko: {
                logoSubtitle: "감정 연금술",
                portalMainTitle: "Portal 01: 깨진 진실의 파편",
                portalSubtitle: "기억 속을 베어가는 진실의 조각들",
                portalIntro: "🔥 \"진실이 항상 빛나는 건 아니에요.\"\n\"어떤 진실은 깨져서 마음 어딘가에 박힌 채,\n시간이 지나도 사라지지 않죠.\"\n\n\"지금 떠오르는 그 '깨진 진실'이 있다면,\n그것은 누구에 대한 것이었고,\n어떤 상황이었나요?\"\n\n\"그 진실은… 당신에게 어떤 흔적을 남겼나요?\"",
                followUpQuestion: "그 '깨진 진실'을 직면한 이후,\n당신은 자신을 어떻게 다루며 살아왔나요?\n그 조각은 지금도 당신 안에서 남아 있나요?",
                lightTitle: "✨ 빛의 한마디",
                lightMessage: "깨진 진실은 사라지지 않았어요.\n단지 새로운 형태로 당신의 지혜가 되었을 뿐이에요.\n상처는 빛이 들어오는 곳이기도 하거든요.",
                navigationTitle: "🔥 Portal 01 완료",
                navigationMessage: "당신은 깨진 진실의 파편과 마주했습니다.\n그 날카로운 조각들은 이제 더 이상 당신을 베지 않을 것입니다.\n오히려 빛을 굴절시켜 새로운 무지개를 만들어낼 거예요.\n\n진실은 완전할 필요가 없다는 것을 알았으니까요.\n깨진 채로도, 충분히 아름다울 수 있다는 것을 배웠으니까요.",
                nextPortalBtn: "Portal 02로 이어가기",
                stayPortalBtn: "이 파편과 더 머물기",
                inputPlaceholder: "떠오르는 그 '깨진 진실'은 무엇인가요? (Enter로 전송)",
                youLabel: "당신",
                waitingMessage: "응답을 기다리는 중..."
            },
            en: {
                logoSubtitle: "Emotional Alchemy",
                portalMainTitle: "Portal 01: Fragments of Broken Truth",
                portalSubtitle: "The pieces of truth that cut through memories",
                portalIntro: "🔥 \"Truth doesn't always shine.\"\n\"Some truths shatter and lodge somewhere in the heart,\nnever disappearing even as time passes.\"\n\n\"If there's a 'broken truth' that comes to mind now,\nwho was it about,\nand what was the situation?\"\n\n\"That truth... what traces did it leave on you?\"",
                followUpQuestion: "After facing that 'broken truth',\nhow have you been treating yourself while living?\nDo those fragments still remain within you?",
                lightTitle: "✨ Word of Light",
                lightMessage: "The broken truth hasn't disappeared.\nIt has simply become your wisdom in a new form.\nWounds are also places where light enters.",
                navigationTitle: "🔥 Portal 01 Complete",
                navigationMessage: "You have faced the fragments of broken truth.\nThose sharp pieces will no longer cut you.\nInstead, they will refract light to create new rainbows.\n\nBecause you've learned that truth doesn't need to be perfect.\nYou've discovered that even broken, it can still be beautiful enough.",
                nextPortalBtn: "Continue to Portal 02",
                stayPortalBtn: "Stay with these fragments",
                inputPlaceholder: "What is that 'broken truth' that comes to mind? (Press Enter to send)",
                youLabel: "You",
                waitingMessage: "Waiting for response..."
            },
            pt: {
                logoSubtitle: "Alquimia Emocional",
                portalMainTitle: "Portal 01: Fragmentos da Verdade Quebrada",
                portalSubtitle: "Os pedaços de verdade que cortam as memórias",
                portalIntro: "🔥 \"A verdade nem sempre brilha.\"\n\"Algumas verdades se quebram e se alojam em algum lugar do coração,\nnunca desaparecendo mesmo com o passar do tempo.\"\n\n\"Se há uma 'verdade quebrada' que vem à mente agora,\nsobre quem era,\ne qual era a situação?\"\n\n\"Essa verdade... que rastros deixou em você?\"",
                followUpQuestion: "Após enfrentar essa 'verdade quebrada',\ncomo você tem se tratado enquanto vive?\nEsses fragmentos ainda permanecem dentro de você?",
                lightTitle: "✨ Palavra de Luz",
                lightMessage: "A verdade quebrada não desapareceu.\nSimplesmente se tornou sua sabedoria em uma nova forma.\nFeridas também são lugares onde a luz entra.",
                navigationTitle: "🔥 Portal 01 Completo",
                navigationMessage: "Você enfrentou os fragmentos da verdade quebrada.\nEsses pedaços afiados não vão mais te cortar.\nEm vez disso, vão refratar a luz para criar novos arco-íris.\n\nPorque você aprendeu que a verdade não precisa ser perfeita.\nVocê descobriu que mesmo quebrada, ainda pode ser bela o suficiente.",
                nextPortalBtn: "Continuar para Portal 02",
                stayPortalBtn: "Ficar com esses fragmentos",
                inputPlaceholder: "Qual é essa 'verdade quebrada' que vem à mente? (Enter para enviar)",
                youLabel: "Você",
                waitingMessage: "Aguardando resposta..."
            }
        };
        
        const characters = [
            { name: "Noah", emoji: "🧑‍🦱", text: {
                ko: "너는 사랑하려 했지만, 그 사랑 속에 숨어 있는 두려움을 외면했구나.",
                en: "You tried to love, but you ignored the fear hidden within that love.",
                pt: "Você tentou amar, mas ignorou o medo escondido dentro desse amor."
            }},
            { name: "Ely", emoji: "🧝‍♀️", text: {
                ko: "무서움은 종종 가장 가까운 사람에게서 태어나. 그건 네 잘못이 아니야.",
                en: "Fear is often born from those closest to us. That's not your fault.",
                pt: "O medo muitas vezes nasce daqueles mais próximos de nós. Isso não é culpa sua."
            }},
            { name: "Sora", emoji: "🧕", text: {
                ko: "조용한 지배는 소리보다 깊은 상처를 남겨요. 그 침묵 안에서 넌 얼마나 작아졌을까.",
                en: "Quiet domination leaves deeper wounds than noise. How small you must have felt in that silence.",
                pt: "A dominação silenciosa deixa feridas mais profundas que o ruído. Como você deve ter se sentido pequeno nesse silêncio."
            }},
            { name: "Kael", emoji: "🧙", text: {
                ko: "진실은 조각났을 때 더 날카롭지. 그 조각이 너를 찔렀다면, 이제는 꺼내야 해.",
                en: "Truth becomes sharper when it's shattered. If those fragments pierced you, now you must remove them.",
                pt: "A verdade fica mais afiada quando é estilhaçada. Se esses fragmentos te perfuraram, agora você deve removê-los."
            }},
            { name: "Mira", emoji: "🧑‍🎨", text: {
                ko: "그의 침묵은 그림자였고, 넌 그 그림자 안에서 자랐구나.",
                en: "His silence was a shadow, and you grew up within that shadow.",
                pt: "O silêncio dele era uma sombra, e você cresceu dentro dessa sombra."
            }},
            { name: "Cris", emoji: "🦸‍♂️", text: {
                ko: "왜 어른이 되는 건 항상 참는 거라고 배워야 했을까? 그게 정의는 아니야.",
                en: "Why did we have to learn that growing up always means enduring? That's not justice.",
                pt: "Por que tivemos que aprender que crescer sempre significa suportar? Isso não é justiça."
            }},
            { name: "Enya", emoji: "🧑‍🚀", text: {
                ko: "진실을 보는 순간, 세계는 조금 부서지지. 하지만 그건 새로운 세계의 서곡이야.",
                en: "The moment you see truth, the world breaks a little. But that's the prelude to a new world.",
                pt: "No momento em que você vê a verdade, o mundo se quebra um pouco. Mas isso é o prelúdio de um novo mundo."
            }},
            { name: "Lian", emoji: "🧘", text: {
                ko: "그 조각난 감정, 이제는 말로 빚어낼 수 있어. 네 안의 침묵이 깨어지고 있어.",
                en: "Those fragmented emotions, now you can shape them into words. The silence within you is breaking.",
                pt: "Essas emoções fragmentadas, agora você pode moldá-las em palavras. O silêncio dentro de você está se quebrando."
            }}
        ];

        function analyzeEmotion(userInput) {
            const input = userInput.toLowerCase();
            
            const emotionKeywords = {
                betrayal: ['betrayed', 'lied', 'deceived', 'trust', 'broken', '배신', '거짓말', '속임', '신뢰', '깨진', 'traído', 'mentiu', 'enganado', 'confiança', 'quebrado'],
                abandonment: ['left', 'abandoned', 'alone', 'gone', 'disappeared', '떠났', '버렸', '혼자', '사라진', 'deixou', 'abandonou', 'sozinho', 'foi embora', 'desapareceu'],
                family: ['father', 'mother', 'parent', 'family', 'dad', 'mom', '아버지', '어머니', '가족', '아빠', '엄마', 'pai', 'mãe', 'família'],
                control: ['control', 'dominate', 'manipulate', 'power', '조종', '지배', '조작', '권력', 'controlar', 'dominar', 'manipular', 'poder'],
                silence: ['silent', 'quiet', 'didn\'t speak', 'no words', '침묵', '조용', '말하지', '무언', 'silencioso', 'quieto', 'não falou', 'sem palavras'],
                fear: ['scared', 'afraid', 'frightened', 'terror', '무서워', '두려워', '겁나', 'assustado', 'com medo', 'aterrorizado'],
                rejection: ['rejected', 'refused', 'denied', 'dismissed', '거절', '거부', '무시', 'rejeitado', 'recusado', 'negado', 'dispensado'],
                discovery: ['found out', 'discovered', 'learned', 'realized', '알게 된', '발견', '깨달았', 'descobriu', 'aprendeu', 'percebeu']
            };
            
            let detectedEmotions = [];
            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                for (const keyword of keywords) {
                    if (input.includes(keyword)) {
                        detectedEmotions.push(emotion);
                        break;
                    }
                }
            }
            
            if (detectedEmotions.length === 0) {
                detectedEmotions = ['general'];
            }
            
            return detectedEmotions[0];
        }
        
        const responseCharacters = [
            {
                name: "Sora", emoji: "🧕",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            betrayal: "스스로를 지키는 법은 때로 외로움이 돼요. 네가 만든 그 거리만큼, 너도 상처받았겠지.",
                            abandonment: "떠난 사람은 네 마음도 함께 가져갔겠지. 그 빈자리가 얼마나 아픈지 알아요.",
                            family: "가족의 상처는 가장 깊어요. 사랑해야 할 사람에게 받은 상처니까요.",
                            control: "조용한 지배는 소리보다 깊은 상처를 남겨요. 그 침묵 안에서 넌 얼마나 작아졌을까.",
                            silence: "말하지 않은 진실은 가장 무거운 짐이 돼요. 그 무게를 혼자 짊어지느라 힘들었겠어요.",
                            fear: "두려움 속에서도 살아남은 당신이 대단해요. 그 용기를 인정해주세요.",
                            rejection: "거절당한 마음은 자신을 의심하게 만들어요. 하지만 그건 당신의 가치와는 무관해요.",
                            discovery: "진실을 발견하는 순간의 충격, 그 아픔을 견뎌낸 당신이 강해요.",
                            general: "그 진실의 조각들이 당신을 아프게 했지만, 이제는 지혜의 일부가 되었어요."
                        },
                        en: {
                            betrayal: "Learning to protect yourself sometimes becomes loneliness. You must have been hurt as much as the distance you created.",
                            abandonment: "The person who left must have taken part of your heart with them. I know how painful that empty space must be.",
                            family: "Family wounds are the deepest. Because they're wounds from those who should have loved you.",
                            control: "Quiet domination leaves deeper wounds than noise. How small you must have felt in that silence.",
                            silence: "Unspoken truth becomes the heaviest burden. It must have been hard carrying that weight alone.",
                            fear: "You're amazing for surviving in that fear. Please acknowledge that courage.",
                            rejection: "A rejected heart makes you doubt yourself. But that has nothing to do with your worth.",
                            discovery: "The shock of discovering truth, you're strong for enduring that pain.",
                            general: "Those fragments of truth hurt you, but now they've become part of your wisdom."
                        },
                        pt: {
                            betrayal: "Aprender a se proteger às vezes se torna solidão. Você deve ter se machucado tanto quanto a distância que criou.",
                            abandonment: "A pessoa que partiu deve ter levado parte do seu coração junto. Sei como esse espaço vazio deve doer.",
                            family: "Feridas familiares são as mais profundas. Porque são feridas daqueles que deveriam ter te amado.",
                            control: "A dominação silenciosa deixa feridas mais profundas que o ruído. Como você deve ter se sentido pequeno nesse silêncio.",
                            silence: "A verdade não dita se torna o fardo mais pesado. Deve ter sido difícil carregar esse peso sozinho.",
                            fear: "Você é incrível por ter sobrevivido nesse medo. Por favor, reconheça essa coragem.",
                            rejection: "Um coração rejeitado faz você duvidar de si mesmo. Mas isso não tem nada a ver com seu valor.",
                            discovery: "O choque de descobrir a verdade, você é forte por ter suportado essa dor.",
                            general: "Esses fragmentos de verdade te machucaram, mas agora se tornaram parte da sua sabedoria."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Ely", emoji: "🧝‍♀️",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            betrayal: "신뢰는 다시 배울 수 있어. 너는 이제 진실을 말할 수 있게 되었으니까.",
                            abandonment: "떠나간 사람이 남긴 빈자리, 그곳에 이제 당신 자신을 채워넣을 수 있어요.",
                            family: "가족의 사랑을 기대했던 당신의 마음은 틀리지 않았어요. 그들이 줄 수 없었을 뿐이에요.",
                            control: "무서움은 종종 가장 가까운 사람에게서 태어나. 그건 네 잘못이 아니야.",
                            silence: "침묵 속에 숨겨진 진실들이 이제 말이 되기 시작했어요. 당신이 용기를 냈으니까요.",
                            fear: "두려움을 느꼈다는 건 당신이 살아있다는 증거예요. 그 감정을 부끄러워하지 마세요.",
                            rejection: "거절은 끝이 아니라 새로운 시작의 신호일 수 있어요. 더 맞는 자리를 찾게 해주니까요.",
                            discovery: "진실을 마주하는 용기, 그것이 당신을 더 강하게 만들었어요.",
                            general: "깨진 진실도 완전한 진실만큼 가치있어요. 당신의 경험이 그것을 증명해요."
                        },
                        en: {
                            betrayal: "Trust can be learned again. Because you've now become able to speak the truth.",
                            abandonment: "The empty space left by those who departed, you can now fill it with yourself.",
                            family: "Your heart that expected family love wasn't wrong. They just couldn't give it.",
                            control: "Fear is often born from those closest to us. That's not your fault.",
                            silence: "The truths hidden in silence are now starting to become words. Because you found courage.",
                            fear: "Feeling fear is proof that you're alive. Don't be ashamed of that emotion.",
                            rejection: "Rejection might not be an end but a signal for a new beginning. It helps you find a more suitable place.",
                            discovery: "The courage to face truth, that's what made you stronger.",
                            general: "Even broken truth is as valuable as complete truth. Your experience proves that."
                        },
                        pt: {
                            betrayal: "A confiança pode ser aprendida novamente. Porque agora você se tornou capaz de falar a verdade.",
                            abandonment: "O espaço vazio deixado por aqueles que partiram, agora você pode preenchê-lo consigo mesmo.",
                            family: "Seu coração que esperava amor familiar não estava errado. Eles apenas não conseguiram dar.",
                            control: "O medo muitas vezes nasce daqueles mais próximos de nós. Isso não é culpa sua.",
                            silence: "As verdades escondidas no silêncio agora estão começando a se tornar palavras. Porque você encontrou coragem.",
                            fear: "Sentir medo é prova de que você está vivo. Não se envergonhe dessa emoção.",
                            rejection: "A rejeição pode não ser um fim, mas um sinal para um novo começo. Ajuda você a encontrar um lugar mais adequado.",
                            discovery: "A coragem de enfrentar a verdade, foi isso que te tornou mais forte.",
                            general: "Mesmo a verdade quebrada é tão valiosa quanto a verdade completa. Sua experiência prova isso."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            },
            {
                name: "Kael", emoji: "🧙",
                getResponse: (userInput, lang) => {
                    const emotion = analyzeEmotion(userInput);
                    
                    const responses = {
                        ko: {
                            betrayal: "이제는 '조심'이 아니라 '선택'의 시간이야. 진실을 직면한 너는, 스스로를 다시 빚을 수 있어.",
                            abandonment: "떠난 것들은 공간을 만들어줘. 그 공간에 이제 더 진실한 것들이 들어올 수 있어.",
                            family: "가족이라는 이름으로 받은 상처는 가장 깊지만, 치유될 때도 가장 강력한 힘이 돼.",
                            control: "진실은 조각났을 때 더 날카롭지. 그 조각이 너를 찔렀다면, 이제는 꺼내야 해.",
                            silence: "말하지 못한 진실은 독이 되지만, 말해진 진실은 약이 돼. 당신이 그 변화를 만들었어.",
                            fear: "두려움은 거짓 안전의 신호야. 진짜 안전은 진실을 마주할 때 온다.",
                            rejection: "거절당한 자리에서 피어나는 자존감이 있어. 그것이 진짜 힘이야.",
                            discovery: "진실을 발견하는 순간은 파괴이자 창조야. 당신은 그 두 과정을 모두 경험했어.",
                            general: "깨진 진실의 조각들이 이제 새로운 모자이크를 만들 수 있어. 더 아름다운 그림으로."
                        },
                        en: {
                            betrayal: "Now it's time for 'choice', not 'caution'. Having faced truth, you can reshape yourself.",
                            abandonment: "What left creates space. More truthful things can now enter that space.",
                            family: "Wounds received in the name of family are deepest, but when healed, they become the most powerful strength.",
                            control: "Truth becomes sharper when shattered. If those fragments pierced you, now you must remove them.",
                            silence: "Unspoken truth becomes poison, but spoken truth becomes medicine. You made that transformation.",
                            fear: "Fear is a signal of false safety. Real safety comes when you face the truth.",
                            rejection: "There's a self-esteem that blooms from the place of rejection. That's real power.",
                            discovery: "The moment of discovering truth is both destruction and creation. You've experienced both processes.",
                            general: "The fragments of broken truth can now form a new mosaic. Into a more beautiful picture."
                        },
                        pt: {
                            betrayal: "Agora é hora de 'escolha', não 'cautela'. Tendo enfrentado a verdade, você pode se remodelar.",
                            abandonment: "O que partiu cria espaço. Coisas mais verdadeiras podem agora entrar nesse espaço.",
                            family: "Feridas recebidas em nome da família são as mais profundas, mas quando curadas, se tornam a força mais poderosa.",
                            control: "A verdade fica mais afiada quando estilhaçada. Se esses fragmentos te perfuraram, agora você deve removê-los.",
                            silence: "A verdade não dita se torna veneno, mas a verdade dita se torna remédio. Você fez essa transformação.",
                            fear: "O medo é um sinal de segurança falsa. A segurança real vem quando você enfrenta a verdade.",
                            rejection: "Há uma autoestima que floresce do lugar da rejeição. Esse é o poder real.",
                            discovery: "O momento de descobrir a verdade é tanto destruição quanto criação. Você experimentou ambos os processos.",
                            general: "Os fragmentos da verdade quebrada podem agora formar um novo mosaico. Em uma imagem mais bela."
                        }
                    };
                    
                    return responses[lang][emotion] || responses[lang]['general'];
                }
            }
        ];
        
        let currentLanguage = 'en';
        let currentUser = null;
        let userResponse = '';
        let journeyStarted = false;
        let currentTypingElement = null;
        let typingIntervals = [];
        let awaitingSecondResponse = false;
        
        function typewriterEffect(element, text, speed = 80) {
            return new Promise((resolve) => {
                if (currentTypingElement) {
                    currentTypingElement.classList.remove('typing-cursor');
                }
                
                let i = 0;
                element.innerHTML = '';
                element.classList.add('typing-cursor');
                currentTypingElement = element;
                
                const typingInterval = setInterval(() => {
                    if (!document.contains(element)) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                        return;
                    }
                    
                    element.innerHTML += text.charAt(i);
                    i++;
                    
                    if (i % 10 === 0) {
                        scrollToFollowTyping(element);
                    }
                    
                    if (i === text.length) {
                        clearInterval(typingInterval);
                        element.classList.remove('typing-cursor');
                        currentTypingElement = null;
                        resolve();
                    }
                }, speed);
                
                typingIntervals.push(typingInterval);
            });
        }
        
        function clearAllTypingEffects() {
            typingIntervals.forEach(interval => clearInterval(interval));
            typingIntervals = [];
            
            if (currentTypingElement) {
                currentTypingElement.classList.remove('typing-cursor');
                currentTypingElement = null;
            }
        }
        
        function scrollToFollowTyping(element) {
            const mainContent = document.getElementById('mainContent');
            const elementRect = element.getBoundingClientRect();
            const containerRect = mainContent.getBoundingClientRect();
            
            if (elementRect.bottom > containerRect.bottom - 150) {
                const scrollTop = mainContent.scrollTop;
                const elementOffsetTop = element.offsetTop;
                const targetScroll = elementOffsetTop - (containerRect.height / 2);
                
                mainContent.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }
        
        function scrollToElement(element) {
            const mainContent = document.getElementById('mainContent');
            const elementOffsetTop = element.offsetTop;
            const containerHeight = mainContent.clientHeight;
            const targetScroll = elementOffsetTop - (containerHeight / 3);
            
            mainContent.scrollTo({
                top: Math.max(0, targetScroll),
                behavior: 'smooth'
            });
        }
        
        function updateLanguageButtons(lang) {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateStaticTranslations(lang) {
            document.getElementById('logoSubtitle').textContent = translations[lang].logoSubtitle;
            document.getElementById('portalMainTitle').textContent = translations[lang].portalMainTitle;
            document.getElementById('portalSubtitle').textContent = translations[lang].portalSubtitle;
            document.getElementById('lightTitle').textContent = translations[lang].lightTitle;
            document.getElementById('navigationTitle').textContent = translations[lang].navigationTitle;
            document.getElementById('nextPortalBtn').textContent = translations[lang].nextPortalBtn;
            document.getElementById('stayPortalBtn').textContent = translations[lang].stayPortalBtn;
            document.getElementById('userTextarea').placeholder = translations[lang].inputPlaceholder;
        }
        
        function changeLanguage(lang) {
            if (!translations[lang] || currentLanguage === lang) return;
            
            currentLanguage = lang;
            updateLanguageButtons(lang);
            updateStaticTranslations(lang);
            
            if (journeyStarted) {
                resetJourney();
                setTimeout(() => {
                    startPortalSequence();
                }, 1000);
            }
        }
        
        function resetJourney() {
            clearAllTypingEffects();
            for (let i = 1; i < 99999; i++) window.clearInterval(i);
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            
            const sectionsToReset = [
                'portalIntroSection', 'characterResponsesSection', 
                'followUpSection', 'userInputSection',
                'userReactionsSection', 'lightMessageSection', 'navigationSection'
            ];
            
            sectionsToReset.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('show');
                    section.style.opacity = '0';
                    if (sectionId === 'characterResponsesSection' || 
                        sectionId === 'userInputSection' || 
                        sectionId === 'userReactionsSection') {
                        section.innerHTML = '';
                    }
                }
            });
            
            document.getElementById('portalIntro').innerHTML = '';
            document.getElementById('followUpQuestion').innerHTML = '';
            document.getElementById('lightMessage').innerHTML = '';
            document.getElementById('navigationMessage').innerHTML = '';
            
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            document.getElementById('mainContent').scrollTop = 0;
            userResponse = '';
            currentTypingElement = null;
            awaitingSecondResponse = false;
        }
        
        function setupLanguageButtons() {
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    changeLanguage(this.dataset.lang);
                });
            });
        }
        
        function setupTextareaAutoResize() {
            const textarea = document.getElementById('userTextarea');
            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 96) + 'px';
            });
        }
        
        function setupInputEvents() {
            const userTextarea = document.getElementById('userTextarea');
            
            userTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const inputValue = this.value.trim();
                    
                    if (inputValue) {
                        processUserInput(inputValue);
                    }
                }
            });
            
            document.getElementById('nextPortalBtn').addEventListener('click', function() {
                // Mark Portal 01 as complete and navigate to Portal 02
                localStorage.setItem('temarix_v4_portal01_complete', 'true');
                localStorage.setItem('temarix_v4_current_portal', '02');
                
                const nextMessage = currentLanguage === 'ko' ? 
                    'Portal 02: 잃어버린 목소리로 이동합니다.' :
                    currentLanguage === 'en' ? 
                    'Moving to Portal 02: Lost Voice.' :
                    'Indo para Portal 02: Voz Perdida.';
                alert(nextMessage);
                
                // Here you would navigate to the next portal
                // window.location.href = 'temarix_v04_02.html?lang=' + currentLanguage;
            });
            
            document.getElementById('stayPortalBtn').addEventListener('click', function() {
                const stayMessage = currentLanguage === 'ko' ? 
                    '깨진 진실의 파편과 더 머물며 깊이 성찰하시겠습니까?' :
                    currentLanguage === 'en' ? 
                    'Do you want to stay longer with the fragments of broken truth for deeper reflection?' :
                    'Deseja ficar mais tempo com os fragmentos da verdade quebrada para reflexão mais profunda?';
                
                if (confirm(stayMessage)) {
                    resetJourney();
                    setTimeout(() => {
                        startPortalSequence();
                    }, 1000);
                }
            });
        }
        
        async function processUserInput(inputText) {
            userResponse = inputText;
            
            if (firebaseInitialized && db) {
                try {
                    await db.collection("temarix_v4_respostas").add({
                        uid: memoryStorage.mockUser.uid,
                        email: memoryStorage.mockUser.email,
                        portal: "v4-01",
                        resposta: inputText,
                        step: awaitingSecondResponse ? "second" : "first",
                        data: firebase.firestore.Timestamp.now(),
                        idioma: currentLanguage
                    });
                    console.log('Response saved to Firestore');
                } catch (error) {
                    console.error('Error saving to Firestore:', error);
                }
            } else {
                console.log('Firebase not available, saved locally:', inputText);
                localStorage.setItem('temarix_v4_portal01_response', JSON.stringify({
                    portal: "v4-01",
                    resposta: inputText,
                    step: awaitingSecondResponse ? "second" : "first",
                    data: new Date().toISOString(),
                    idioma: currentLanguage
                }));
            }
            
            disableUserInput();
            showUserResponse(inputText);
            
            setTimeout(() => {
                if (!awaitingSecondResponse) {
                    showUserReactions(inputText);
                } else {
                    showSecondUserReactions(inputText);
                }
            }, 1000);
        }
        
        function disableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = true;
            userTextarea.value = '';
            userTextarea.style.height = 'auto';
            userTextarea.placeholder = translations[currentLanguage].waitingMessage;
        }
        
        function enableUserInput() {
            const userTextarea = document.getElementById('userTextarea');
            userTextarea.disabled = false;
            userTextarea.placeholder = translations[currentLanguage].inputPlaceholder;
            
            setTimeout(() => {
                userTextarea.focus();
            }, 100);
        }
        
        function showUserResponse(text) {
            const inputSection = document.getElementById('userInputSection');
            const userDiv = document.createElement('div');
            userDiv.className = 'user-response';
            const youLabel = translations[currentLanguage].youLabel;
            userDiv.innerHTML = '<strong>' + youLabel + ':</strong> "' + text + '"';
            inputSection.appendChild(userDiv);
            inputSection.classList.add('show');
            
            setTimeout(() => {
                scrollToElement(inputSection);
            }, 100);
        }
        
        async function showUserReactions(userInput) {
            const reactionsSection = document.getElementById('userReactionsSection');
            reactionsSection.classList.add('show');
            
            for (let i = 0; i < responseCharacters.length; i++) {
                const char = responseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < responseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showFollowUpQuestion();
            }, 2000);
        }
        
        async function showFollowUpQuestion() {
            const followUpSection = document.getElementById('followUpSection');
            const followUpQuestionEl = document.getElementById('followUpQuestion');
            
            followUpSection.classList.add('show');
            
            await typewriterEffect(followUpQuestionEl, translations[currentLanguage].followUpQuestion, 50);
            
            setTimeout(() => {
                awaitingSecondResponse = true;
                enableUserInput();
            }, 1500);
        }
        
        async function showSecondUserReactions(userInput) {
            // Show second round of character responses (3 characters as per the story)
            const secondResponseCharacters = [
                {
                    name: "Sora", emoji: "🧕",
                    getResponse: (input, lang) => {
                        const responses = {
                            ko: "스스로를 지키는 법은 때로 외로움이 돼요. 네가 만든 그 거리만큼, 너도 상처받았겠지.",
                            en: "Learning to protect yourself sometimes becomes loneliness. You must have been hurt as much as the distance you created.",
                            pt: "Aprender a se proteger às vezes se torna solidão. Você deve ter se machucado tanto quanto a distância que criou."
                        };
                        return responses[lang];
                    }
                },
                {
                    name: "Ely", emoji: "🧝‍♀️",
                    getResponse: (input, lang) => {
                        const responses = {
                            ko: "신뢰는 다시 배울 수 있어. 너는 이제 진실을 말할 수 있게 되었으니까.",
                            en: "Trust can be learned again. Because you've now become able to speak the truth.",
                            pt: "A confiança pode ser aprendida novamente. Porque agora você se tornou capaz de falar a verdade."
                        };
                        return responses[lang];
                    }
                },
                {
                    name: "Kael", emoji: "🧙",
                    getResponse: (input, lang) => {
                        const responses = {
                            ko: "이제는 '조심'이 아니라 '선택'의 시간이야. 진실을 직면한 너는, 스스로를 다시 빚을 수 있어.",
                            en: "Now it's time for 'choice', not 'caution'. Having faced truth, you can reshape yourself.",
                            pt: "Agora é hora de 'escolha', não 'cautela'. Tendo enfrentado a verdade, você pode se remodelar."
                        };
                        return responses[lang];
                    }
                }
            ];
            
            const reactionsSection = document.getElementById('userReactionsSection');
            
            for (let i = 0; i < secondResponseCharacters.length; i++) {
                const char = secondResponseCharacters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                reactionsSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                const reactionText = char.getResponse(userInput, currentLanguage);
                await typewriterEffect(dialogueDiv, reactionText, 70);
                
                if (i < secondResponseCharacters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                showLightMessage();
            }, 2000);
        }
        
        async function showLightMessage() {
            const lightSection = document.getElementById('lightMessageSection');
            const lightMessageEl = document.getElementById('lightMessage');
            
            lightSection.classList.add('show');
            
            await typewriterEffect(lightMessageEl, translations[currentLanguage].lightMessage, 60);
            
            setTimeout(() => {
                showNavigationSection();
            }, 2000);
        }
        
        async function showNavigationSection() {
            const navigationSection = document.getElementById('navigationSection');
            const navigationMessage = document.getElementById('navigationMessage');
            
            navigationSection.classList.add('show');
            
            const messageText = translations[currentLanguage].navigationMessage;
            await typewriterEffect(navigationMessage, messageText, 50);
            
            setTimeout(() => {
                scrollToElement(navigationSection);
            }, 500);
        }
        
        function initializeTemarix() {
            console.log('Temarix V4 Portal 01 initialized');
            
            setupLanguageButtons();
            setupTextareaAutoResize();
            setupInputEvents();
            
            journeyStarted = true;
            
            setTimeout(() => {
                startPortalSequence();
            }, 1000);
        }
        
        function startPortalSequence() {
            setTimeout(() => {
                showIntro();
            }, 1000);
        }
        
        async function showIntro() {
            const introSection = document.getElementById('portalIntroSection');
            const introElement = document.getElementById('portalIntro');
            
            introSection.classList.add('show');
            
            await typewriterEffect(introElement, translations[currentLanguage].portalIntro, 60);
            
            setTimeout(() => {
                showCharacterResponses();
            }, 2000);
        }
        
        async function showCharacterResponses() {
            const responseSection = document.getElementById('characterResponsesSection');
            responseSection.classList.add('show');
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const responseDiv = document.createElement('div');
                responseDiv.className = 'character-response';
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'character-name';
                nameDiv.textContent = char.emoji + ' ' + char.name;
                
                const dialogueDiv = document.createElement('div');
                dialogueDiv.className = 'character-dialogue';
                
                responseDiv.appendChild(nameDiv);
                responseDiv.appendChild(dialogueDiv);
                responseSection.appendChild(responseDiv);
                
                responseDiv.style.opacity = '1';
                
                await typewriterEffect(dialogueDiv, char.text[currentLanguage], 70);
                
                if (i < characters.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
            
            setTimeout(() => {
                enableUserInput();
            }, 2000);
        }
        
        function getLanguageFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');
            return lang && translations[lang] ? lang : 'en';
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Temarix V4 Portal 01 DOM loaded');
            
            initializeFirebase();
            
            currentLanguage = getLanguageFromURL();
            
            currentUser = { 
                uid: 'user-auto-' + Date.now(),
                email: 'auto@temarix.com'
            };
            
            memoryStorage.mockUser = currentUser;
            
            updateStaticTranslations(currentLanguage);
            updateLanguageButtons(currentLanguage);
            initializeTemarix();
        });
    </script>
</body>
</html>
            